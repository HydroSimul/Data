[
  {
    "objectID": "Postprocess/PP_0.html",
    "href": "Postprocess/PP_0.html",
    "title": "Post-Processing",
    "section": "",
    "text": "About this site test1\n\n1 + 1\n\n[1] 2\n\n\n\n\nAbout this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Postprocess/PP_0.html#h2",
    "href": "Postprocess/PP_0.html#h2",
    "title": "Post-Processing",
    "section": "",
    "text": "About this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcom Page",
    "section": "",
    "text": "Welcome to HydroSimul: Your Gateway to Understanding Hydrological Simulation\nWe’re thrilled to have you at HydroSimul, your premier resource for delving into the realm of hydrological simulation. Here, we curate a vast collection of datasets and offer cutting-edge techniques to empower your exploration.\nAt HydroSimul, we believe in the power of collaboration. If you want to share your knowledge, experience, and skills in the field, please contact us at hydro.simul@gmail.com. We also welcome your advice.\nOur website serves as a comprehensive hub for your hydrological journey:"
  },
  {
    "objectID": "index.html#dataset-collection",
    "href": "index.html#dataset-collection",
    "title": "Welcom Page",
    "section": "1. Dataset Collection:",
    "text": "1. Dataset Collection:\nNumerous open-access datasets are readily available for use in hydrological modeling, including meteorological, hydrological, and various geophysical datasets. Within this dataset collection, we not only provide direct links to the datasets but also present essential information in a standardized format, simplifying your dataset selection process. Additionally, we strive to establish connections with research papers that have utilized these datasets and offer valuable feedback gleaned from these sources."
  },
  {
    "objectID": "index.html#data-processing",
    "href": "index.html#data-processing",
    "title": "Welcom Page",
    "section": "2. Data Processing:",
    "text": "2. Data Processing:\nOn this page, we provide you with a wealth of data processing tools and techniques. Discover how to adeptly clean, preprocess, and convert raw hydrological data into a valuable format suitable for analysis and modeling."
  },
  {
    "objectID": "index.html#data-analysis",
    "href": "index.html#data-analysis",
    "title": "Welcom Page",
    "section": "3. Data Analysis:",
    "text": "3. Data Analysis:\nUncover concealed statistical insights and trends within your data. Our comprehensive guides and tutorials are designed to empower you with the skills to effectively analyze hydrological data."
  },
  {
    "objectID": "index.html#hydrological-modeling",
    "href": "index.html#hydrological-modeling",
    "title": "Welcom Page",
    "section": "4. Hydrological Modeling:",
    "text": "4. Hydrological Modeling:\nTake your understanding to the next level with hydrological modeling. Explore various models and model frameworks and acquire hands-on experience in simulating complex hydrological processes. Additionally, we provide extensive resources on calibration algorithms and strategies to significantly improve your modeling outcomes."
  },
  {
    "objectID": "dataset/index.html",
    "href": "dataset/index.html",
    "title": "Dataset",
    "section": "",
    "text": "Numerous open-access datasets are readily available for use in hydrological modeling, including meteorological, hydrological, and various geophysical datasets. Within this dataset collection, we not only provide direct links to the datasets but also present essential information in a standardized format, simplifying your dataset selection process. Additionally, we strive to establish connections with research papers that have utilized these datasets and offer valuable feedback gleaned from these sources."
  },
  {
    "objectID": "dataset/geoph.html",
    "href": "dataset/geoph.html",
    "title": "Geophysical",
    "section": "",
    "text": "About this site test1\n\n1 + 1\n\n[1] 2\n\n\n\n\nAbout this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataset/geoph.html#h2",
    "href": "dataset/geoph.html#h2",
    "title": "Geophysical",
    "section": "",
    "text": "About this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataprocess/NetCDF.html",
    "href": "dataprocess/NetCDF.html",
    "title": "NetCDF",
    "section": "",
    "text": "About this site test1\n\n1 + 1\n\n[1] 2\n\n\n\n\nAbout this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataprocess/NetCDF.html#h2",
    "href": "dataprocess/NetCDF.html#h2",
    "title": "NetCDF",
    "section": "",
    "text": "About this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataprocess/basic_format.html",
    "href": "dataprocess/basic_format.html",
    "title": "Basic format",
    "section": "",
    "text": "In hydrological modeling, various data formats are used to represent and manage different types of data. The choice of data format depends on the nature of the data, the modeling software being used, and specific project requirements. Here are some common data formats used in hydrological modeling, along with their key features:"
  },
  {
    "objectID": "dataprocess/basic_format.html#ascii",
    "href": "dataprocess/basic_format.html#ascii",
    "title": "Basic format",
    "section": "ASCII",
    "text": "ASCII\nASCII (American Standard Code for Information Interchange) is a plain text format, making it human-readable.\n\nAdvantages\n\nHuman-Readable: Users can easily view, understand, and edit the data directly in a text editor.\nWidespread Support, Ease of Import/Export: ASCII is universally supported. Most programming languages, data analysis tools, and software applications can read and write ASCII files, ensuring high compatibility.\nLightweight: ASCII files are typically lightweight and do not consume excessive storage space, making them suitable for large datasets.\nSimple Structure: ASCII files have a straightforward structure, often using lines of text with fields separated by delimiters. This simplicity aids in data extraction and manipulation.\n\n\n\nDisadvantages\n\nLimited Data Types: ASCII primarily handles text-based data and is not suitable for complex data types such as images, multimedia, or hierarchical data.\nNo Inherent Data Validation: ASCII files lack built-in mechanisms for data validation or integrity checks, requiring users to ensure data conformity.\nLack of Compression: ASCII files do not inherently support data compression, potentially resulting in larger file sizes compared to binary formats.\nLimited Metadata: ASCII format lacks standardized metadata structures common in other formats, making comprehensive data documentation challenging.\nSlower Reading/Writing: Reading and writing data in ASCII format may be slower, especially for large datasets, due to additional parsing required to interpret text-based data.\n\n\n\nfile format for ASCII data\n\n.txt: This is the most generic and widely used file extension for plain text files. It doesn’t imply any specific format or structure; it’s just a simple text file.\n.csv (Comma-Separated Values): While CSV files contain data separated by commas, they are still considered ASCII files because they use plain text characters to represent data values. Each line in a CSV file typically represents a record, with values separated by commas."
  },
  {
    "objectID": "dataprocess/basic_format.html#binary",
    "href": "dataprocess/basic_format.html#binary",
    "title": "Basic format",
    "section": "Binary",
    "text": "Binary\n\nAdvantages of Binary Formats\n\nEfficiency: Binary formats are highly efficient for data storage and transmission because they represent data in a compact binary form. This can significantly reduce storage space and data transfer times, making them ideal for large datasets.\nData Integrity: Binary formats often include built-in mechanisms for data integrity and error checking. This helps ensure that data remains intact and accurate during storage and transmission.\nComplex Data: Binary formats can represent complex data structures, including images, multimedia, and hierarchical data, in a way that maintains data integrity and structure. This makes them suitable for a wide range of data types.\nFaster I/O: Reading and writing data in binary format is generally faster than text-based formats like ASCII. This efficiency is particularly important for applications that require high-speed data processing.\nSecurity: Binary formats can provide a level of data security because they are not easily human-readable. This can be advantageous when dealing with sensitive information.\n\n\n\nDisadvantages of Binary Formats\n\nLack of Human-Readability: Binary formats are not human-readable, making it difficult to view or edit the data directly. This can be a disadvantage when data inspection or manual editing is required.\nCompatibility: Binary formats may not be universally compatible across different software platforms and programming languages. This can lead to issues when sharing or accessing data in various environments.\nLimited Metadata: Binary formats may not include comprehensive metadata structures, making it challenging to document and describe the data effectively.\nVersion Compatibility: Changes in the binary format’s structure or encoding can lead to compatibility issues when working with data created using different versions of software or hardware.\nDebugging and Troubleshooting: Debugging and troubleshooting binary data can be more challenging compared to human-readable formats like ASCII. Detecting and resolving issues may require specialized tools and expertise.\nPlatform Dependence: Binary formats can be platform-dependent, meaning they may not be easily transferable between different operating systems or hardware architectures.\n\nBinary formats are a valuable choice for certain applications, particularly when efficiency, data integrity, and complex data types are crucial. However, they may not be suitable for all scenarios, especially when human readability, compatibility, or ease of data inspection is essential.\n\n\nNectCDF\nNetCDF (Network Common Data Form) is a versatile data format widely used in scientific and environmental applications. It is primarily a binary data format, but it includes structured elements for efficient data storage and management. Here are some key characteristics of NetCDF:\n\nBinary Representation: NetCDF data files are primarily stored in binary format, which enables efficient storage and handling of numerical data, particularly floating-point numbers.\nSelf-Describing: NetCDF files are self-describing, meaning they include metadata alongside the data. This metadata provides essential information about the data’s structure, dimensions, units, and other attributes.\nHierarchical Structure: NetCDF supports a hierarchical structure capable of representing complex data types, including multi-dimensional arrays and groups of data variables.\nData Compression: NetCDF allows for data compression, which can reduce the storage space required for large datasets while maintaining data integrity.\nPlatform-Independent: NetCDF files are designed to be platform-independent, ensuring compatibility across various operating systems and hardware architectures.\nLanguage Support: NetCDF libraries and tools are available for multiple programming languages, making it accessible to a wide range of scientific and data analysis applications.\n\nNetCDF’s combination of binary efficiency and structured metadata makes it an invaluable choice for storing and sharing scientific data, particularly in fields such as meteorology, oceanography, and environmental science.\n\n\nOther row data from"
  },
  {
    "objectID": "dataprocess/index.html",
    "href": "dataprocess/index.html",
    "title": "Dataset",
    "section": "",
    "text": "Numerous open-access datasets are readily available for use in hydrological modeling, including meteorological, hydrological, and various geophysical datasets. Within this dataset collection, we not only provide direct links to the datasets but also present essential information in a standardized format, simplifying your dataset selection process. Additionally, we strive to establish connections with research papers that have utilized these datasets and offer valuable feedback gleaned from these sources."
  },
  {
    "objectID": "dataprocess/spatial_data.html",
    "href": "dataprocess/spatial_data.html",
    "title": "spatial data",
    "section": "",
    "text": "About this site test1\n\n1 + 1\n\n[1] 2\n\n\n\n\nAbout this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataprocess/spatial_data.html#h2",
    "href": "dataprocess/spatial_data.html#h2",
    "title": "spatial data",
    "section": "",
    "text": "About this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataset/hydro.html",
    "href": "dataset/hydro.html",
    "title": "Hydro",
    "section": "",
    "text": "About this site test1\n\n1 + 1\n\n[1] 2\n\n\n\n\nAbout this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataset/hydro.html#h2",
    "href": "dataset/hydro.html#h2",
    "title": "Hydro",
    "section": "",
    "text": "About this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataset/meteo.html",
    "href": "dataset/meteo.html",
    "title": "Meteological",
    "section": "",
    "text": "About this site test1\n\n1 + 1\n\n[1] 2\n\n\n\n\nAbout this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataset/meteo.html#h2",
    "href": "dataset/meteo.html#h2",
    "title": "Meteological",
    "section": "",
    "text": "About this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Modelling/HM_0.html",
    "href": "Modelling/HM_0.html",
    "title": "Modelling",
    "section": "",
    "text": "About this site test1\n\n1 + 1\n\n[1] 2\n\n\n\n\nAbout this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Modelling/HM_0.html#h2",
    "href": "Modelling/HM_0.html#h2",
    "title": "Modelling",
    "section": "",
    "text": "About this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataprocess/data_workspace.html",
    "href": "dataprocess/data_workspace.html",
    "title": "Data in Workspace",
    "section": "",
    "text": "More Details in R for Data Science (2e)"
  },
  {
    "objectID": "dataprocess/data_workspace.html#coding-basics",
    "href": "dataprocess/data_workspace.html#coding-basics",
    "title": "Data in Workspace",
    "section": "Coding basics",
    "text": "Coding basics\n\nmath calculations:\n\n‘+’\n‘-’\n’*’\n‘/’\nTrigonometric functions\n\n\nRPython\n\n\n\n1 / 200 * 30\n\n[1] 0.15\n\n(59 + 73 - 2) / 3\n\n[1] 43.33333\n\n3^2\n\n[1] 9\n\nsin(pi / 2) # pi as Const number in R\n\n[1] 1\n\n\n\n\n\n\n\n\n\n\nCreate new objects\n\nRPython\n\n\nCreate new objects with the assignment operator &lt;-:\n\n# \"&lt;-\" special in R \n\na &lt;- 1 / 200 * 30\nb &lt;- a + 1\n\n\n\n\n\n\n\n\n\nNaming rules\n\nRPython\n\n\n\nmust start with a letter\ncan only contain letters, numbers, underscores _, and dot .\ncase-sensitive (age, Age and AGE are three different variables)\ncannot be any of the Reserved Words\n\nTRUE FALSE\nNULL Inf NaN NA NA_real NA_complex_ NA_character_\nif else\nfor while repeat\nnext break\nfunction\nin\n\n\n\n\n\n\n\n\n\n\nLegal\n\n\n\ni_use_snake_case\notherPeopleUseCamelCase\nsome.people.use.periods\naFew.People_RENOUNCEconvention6\n\n\n\n\n\n\n\n\n\n\n\nIllegal\n\n\n\n_start_with_underscores\n1_start_with_number\nif\ncontain sapce\ncontain-other+charater\n\n\n\n\nmore Reserved Words in:\nhelp(\"reserved\")\n\n\n\nmust start with a letter or the underscore character _\ncan only contain letters, numbers, and underscores _\ncase-sensitive (age, Age and AGE are three different variables)\ncannot be any of the Python keywords (35 keywors in Python 3.8)\n\nTrue False\nNone\nif else elif\nfor while repeat\ntry break continue finally\ndef\nin and or not\nreturn\n\n\n\n\n\n\n\n\n\n\nLegal\n\n\n\ni_use_snake_case\n_start_with_underscores\notherPeopleUseCamelCase\naFew_People_RENOUNCEconvention6\n\n\n\n\n\n\n\n\n\n\n\nIllegal\n\n\n\nwant.contain.dot\n1_start_with_number\nif\ncontain sapce\ncontain-other+charater\n\n\n\n\nMore Keywords in:\n&gt;&gt;&gt; help(\"keywords\")\n\n\n\n\nProgramming Naming Conventions\n\nCamel Case\n\nEach word, except the first, starts with a capital letter:\nmyVariableName\n\nPascal Case\n\nEach word starts with a capital letter:\nMyVariableName\n\nSnake Case\n\nEach word is separated by an underscore character:\nmy_variable_name"
  },
  {
    "objectID": "dataprocess/data_workspace.html#function",
    "href": "dataprocess/data_workspace.html#function",
    "title": "Data in Workspace",
    "section": "Function",
    "text": "Function\n\nCalling\n\nRPython\n\n\nCalling Syntax:\n\nfunction_name(argument1 = value1, argument2 = value2, ...)\n\nWe can also check the arguments and other information with:\n?seq\nTry using seq(), which makes regular sequences of numbers:\n\nseq(from = 1, to = 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWe often omit the names of the first several arguments in function calls, so we can rewrite this as follows:\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10"
  },
  {
    "objectID": "dataprocess/basic_r_python.html",
    "href": "dataprocess/basic_r_python.html",
    "title": "R & Python Basic",
    "section": "",
    "text": "More Details of R in R for Data Science (2e) and Advanced R\nMore Details of Python in W3 School Python\nThis article serves as a brief introduction to the fundamental coding aspects of both R and Python. It provides a first impression of these scripting languages. For a more comprehensive understanding and in-depth techniques related to both languages, you are encouraged to explore the website mentioned above. The content here is primarily a condensed compilation of information from the provided links, aimed at facilitating a comparison between R and Python.\nData and Functions are the two essential components of every programming language, especially in the context of data science and data processing. They can be likened to nouns and verbs in natural languages. Data describes information, while Functions define actions for manipulating that data.\nThis article is divided into two main sections: Data (Section 1) and Coding (Section 2).\nIn the Data section, we will explore:\nIn the Coding section, we will delve into three key aspects:\nThe above five elements can be considered as the most fundamental elements of every scripting language. Additionally, we will explore object creation and naming in a section called ‘New Objects’ (Section 3). Objects can encompass functions and variables, further enriching our understanding of scripting.\nThis article will provide a solid introduction to the core concepts in programming, laying the groundwork for further exploration in both R and Python."
  },
  {
    "objectID": "dataprocess/basic_r_python.html#naming-rules",
    "href": "dataprocess/basic_r_python.html#naming-rules",
    "title": "R & Python Basic",
    "section": "3.1 Naming rules",
    "text": "3.1 Naming rules\n\nRPython\n\n\n\nmust start with a letter\ncan only contain letters, numbers, underscores _, and dot .\ncase-sensitive (age, Age and AGE are three different variables)\ncannot be any of the Reserved Words\n\nTRUE FALSE\nNULL Inf NaN NA NA_real NA_complex_ NA_character_\nif else\nfor while repeat\nnext break\nfunction\nin\n\n\n\n\n\n\n\n\n\n\nLegal\n\n\n\ni_use_snake_case\notherPeopleUseCamelCase\nsome.people.use.periods\naFew.People_RENOUNCEconvention6\n\n\n\n\n\n\n\n\n\n\n\nIllegal\n\n\n\n_start_with_underscores\n1_start_with_number\nif\ncontain sapce\ncontain-other+charater\n\n\n\n\nmore Reserved Words in:\nhelp(\"reserved\")\n\n\n\nmust start with a letter or the underscore character _\ncan only contain letters, numbers, and underscores _\ncase-sensitive (age, Age and AGE are three different variables)\ncannot be any of the Python keywords (35 keywors in Python 3.8)\n\nTrue False\nNone\nif else elif\nfor while repeat\ntry break continue finally\ndef\nin and or not\nreturn\n\n\n\n\n\n\n\n\n\n\nLegal\n\n\n\ni_use_snake_case\n_start_with_underscores\notherPeopleUseCamelCase\naFew_People_RENOUNCEconvention6\n\n\n\n\n\n\n\n\n\n\n\nIllegal\n\n\n\nwant.contain.dot\n1_start_with_number\nif\ncontain sapce\ncontain-other+charater\n\n\n\n\nMore Keywords in:\n\nhelp(\"keywords\")"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#programming-naming-conventions",
    "href": "dataprocess/basic_r_python.html#programming-naming-conventions",
    "title": "R & Python Basic",
    "section": "3.2 Programming Naming Conventions",
    "text": "3.2 Programming Naming Conventions\n\nCamel Case\n\nEach word, except the first, starts with a capital letter:\nmyVariableName\n\nPascal Case\n\nEach word starts with a capital letter:\nMyVariableName\n\nSnake Case\n\nEach word is separated by an underscore character:\nmy_variable_name"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#calling",
    "href": "dataprocess/basic_r_python.html#calling",
    "title": "Coding basics",
    "section": "Calling",
    "text": "Calling\n\nRPython\n\n\nCalling Syntax:\n\nfunction_name(argument1 = value1, argument2 = value2, ...)\n\nTry using seq(), which makes regular sequences of numbers:\n\nseq(from = 1, to = 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWe often omit the names of the first several arguments in function calls, so we can rewrite this as follows:\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWe can also check the arguments and other information with:\n?seq\nThe “help” windows shows as:\n\n\n\n\nsequence = list(range(1, 11))\nprint(sequence)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#define",
    "href": "dataprocess/basic_r_python.html#define",
    "title": "Coding basics",
    "section": "Define",
    "text": "Define\n\nRPython\n\n\nuse the function() keyword:\n\nmy_add1 &lt;- function(x) { # create a function with the name my_function\n  x + 1\n}\n\ncalling the function my_add1:\n\nmy_add1(2)\n\n[1] 3"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#choices",
    "href": "dataprocess/basic_r_python.html#choices",
    "title": "Coding basics",
    "section": "choices",
    "text": "choices\n\nBasic If-Else\n\nRPython\n\n\nThe basic form of an if statement in R is as follows:\n\nif (condition) true_action\nif (condition) true_action else false_action\n\nIf condition is TRUE, true_action is evaluated; if condition is FALSE, the optional false_action is evaluated.\nTypically the actions are compound statements contained within {:\nif returns a value so that you can assign the results:\n\na &lt;- 6\nb &lt;- 8\n\nif (b &gt; a) {\n  cat(\"b is greater than a\\n\")\n} else if (a == b) {\n  cat(\"a and b are equal\\n\")\n} else {\n  cat(\"a is greater than b\\n\")\n}\n\nb is greater than a\n\n\n\n\n\n# if statements\nif condition: \n  true_action\n  \n# if-else\nif condition: \n  true_action \nelse: \n  false_action\n\n\n# if-ifel-else\nif condition1: \n  true_action1 \nelif condition2: \n  true_action2 \nelse: \n  false_action\n\n\na = 6\nb = 8\nif b &gt; a:\n  print(\"b is greater than a\")\nelif a == b:\n  print(\"a and b are equal\")\nelse:\n  print(\"a is greater than b\")\n\nb is greater than a\n\n\n\n\n\n\n\nswitch\n\nRPython\n\n\nClosely related to if is the switch()-statement. It’s a compact, special purpose equivalent that lets you replace code like:\n\nx_option &lt;- function(x) {\n  if (x == \"a\") {\n    \"option 1\"\n  } else if (x == \"b\") {\n    \"option 2\" \n  } else if (x == \"c\") {\n    \"option 3\"\n  } else {\n    stop(\"Invalid `x` value\")\n  }\n}\n\nwith the more succinct:\n\nx_option &lt;- function(x) {\n  switch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\",\n    stop(\"Invalid `x` value\")\n  )\n}\nx_option(\"b\")\n\n[1] \"option 2\"\n\n\nThe last component of a switch() should always throw an error, otherwise unmatched inputs will invisibly return NULL:\n\n\n\nmatch subject:\n    case &lt;pattern_1&gt;:\n        &lt;action_1&gt;\n    case &lt;pattern_2&gt;:\n        &lt;action_2&gt;\n    case &lt;pattern_3&gt;:\n        &lt;action_3&gt;\n    case _:\n        &lt;action_wildcard&gt;\n\n\ndef x_option(x):\n    options = {\n        \"a\": \"option 1\",\n        \"b\": \"option 2\",\n        \"c\": \"option 3\"\n    }\n    return options.get(x, \"Invalid `x` value\")\n\nprint(x_option(\"b\"))\n\noption 2\n\n\n\n\n\n\n\nVectorised if\n\nRPython\n\n\nGiven that if only works with a single TRUE or FALSE, you might wonder what to do if you have a vector of logical values. Handling vectors of values is the job of ifelse(): a vectorised function with test, yes, and no vectors (that will be recycled to the same length):\n\nx &lt;- 1:10\nifelse(x %% 5 == 0, \"XXX\", as.character(x))\n\n [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n\nifelse(x %% 2 == 0, \"even\", \"odd\")\n\n [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n\n\nNote that missing values will be propagated into the output.\nI recommend using ifelse() only when the yes and no vectors are the same type as it is otherwise hard to predict the output type. See https://vctrs.r-lib.org/articles/stability.html#ifelse for additional discussion."
  },
  {
    "objectID": "dataprocess/basic_r_python.html#loops",
    "href": "dataprocess/basic_r_python.html#loops",
    "title": "Coding basics",
    "section": "Loops",
    "text": "Loops\n\nfor-Loops\nA for loop is used for iterating over a sequence (that is either a list, a tuple, a dictionary, a set, or a string). For each item in vector, perform_action is called once; updating the value of item each time.\n\nRPython\n\n\nIn R, for loops are used to iterate over items in a vector. They have the following basic form:\n\nfor (item in vector) perform_action\n\n\nfor (i in 1:3) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n\n\n\n\n\nfor item in vector \n  perform_action\n\n\nfor i in range(1, 3):\n  print(i)\n\n1\n2\n\n\n\n\n\n\n\nwhile-Loops\nWith the while loop we can execute a set of statements as long as a condition is TRUE:\n\nRPython\n\n\n\ni &lt;- 1\nwhile (i &lt; 6) {\n  print(i)\n  i &lt;- i + 1\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\n\n\n\ni = 1\nwhile i &lt; 6:\n  print(i)\n  i += 1\n\n1\n2\n3\n4\n5\n\n\n\n\n\n\n\nterminate\n\nRPython\n\n\nThere are two ways to terminate a for loop early:\n\nnext exits the current iteration.\nbreak exits the entire for loop.\n\n\nfor (i in 1:10) {\n  if (i &lt; 3) \n    next\n\n  print(i)\n  \n  if (i &gt;= 5)\n    break\n}\n\n[1] 3\n[1] 4\n[1] 5\n\n\n\n\n\nfor i in range(1, 10):\n    if i &lt; 3:\n        continue\n    \n    print(i)\n    \n    if i &gt;= 5:\n        break\n\n3\n4\n5"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#creating",
    "href": "dataprocess/basic_r_python.html#creating",
    "title": "Coding basics",
    "section": "Creating",
    "text": "Creating\n\nRPython\n\n\nUse the function() keyword:\n\nmy_add1 &lt;- function(x) {\n  x + 1\n}\n\ncalling the function my_add1:\n\nmy_add1(2)\n\n[1] 3\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn R, the return statement is not essential for a function to yield a value as its result. By default, R will return the result of the last command within the function as its output.\n\n\n\n\nIn Python a function is defined using the def keyword:\n\ndef my_add(x):\n  return x + 1\n\ncalling the function my_add1:\n\nprint(my_add(2))\n\n3\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe return statement is essential for a function to yield a value as its result."
  },
  {
    "objectID": "dataprocess/basic_r_python.html#datatype",
    "href": "dataprocess/basic_r_python.html#datatype",
    "title": "R & Python Basic",
    "section": "1.1 Datatype",
    "text": "1.1 Datatype"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#data-structure",
    "href": "dataprocess/basic_r_python.html#data-structure",
    "title": "R & Python Basic",
    "section": "1.2 Data Structure",
    "text": "1.2 Data Structure"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#math-calculations",
    "href": "dataprocess/basic_r_python.html#math-calculations",
    "title": "R & Python Basic",
    "section": "2.1 math calculations",
    "text": "2.1 math calculations\n\n‘+’ ‘-’ ’*’ ‘/’\nExponent, Logarithm\nTrigonometric functions\nLinear algebra, Matrix multiplication\n\n\nRPython\n\n\n\n1 / 200 * 30\n\n[1] 0.15\n\n(59 + 73 - 2) / 3\n\n[1] 43.33333\n\n3^2\n\n[1] 9\n\nsin(pi / 2) # pi as Const number in R\n\n[1] 1\n\n\n\n\n\nprint(1 / 200 * 30)\n\n0.15\n\nprint((59 + 73 - 2) / 3)\n\n43.333333333333336\n\nprint(3**2)\n\n9\n\nimport math\nprint(math.sin(math.pi/2))\n\n1.0"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#control-flow",
    "href": "dataprocess/basic_r_python.html#control-flow",
    "title": "R & Python Basic",
    "section": "2.2 Control flow",
    "text": "2.2 Control flow\nThere are two primary tools of control flow: choices and loops.\n\nChoices, like if statements calls, allow you to run different code depending on the input.\nLoops, like for and while, allow you to repeatedly run code, typically with changing options.\n\n\n2.2.1 choices\n\n2.2.1.1 Basic If-Else\n\nRPython\n\n\nThe basic form of an if statement in R is as follows:\n\nif (condition) true_action\nif (condition) true_action else false_action\n\nIf condition is TRUE, true_action is evaluated; if condition is FALSE, the optional false_action is evaluated.\nTypically the actions are compound statements contained within {:\nif returns a value so that you can assign the results:\n\na &lt;- 6\nb &lt;- 8\n\nif (b &gt; a) {\n  cat(\"b is greater than a\\n\")\n} else if (a == b) {\n  cat(\"a and b are equal\\n\")\n} else {\n  cat(\"a is greater than b\\n\")\n}\n\nb is greater than a\n\n\n\n\n\n# if statements\nif condition: \n  true_action\n  \n# if-else\nif condition: \n  true_action \nelse: \n  false_action\n\n\n# if-ifel-else\nif condition1: \n  true_action1 \nelif condition2: \n  true_action2 \nelse: \n  false_action\n\n\na = 6\nb = 8\nif b &gt; a:\n  print(\"b is greater than a\")\nelif a == b:\n  print(\"a and b are equal\")\nelse:\n  print(\"a is greater than b\")\n\nb is greater than a\n\n\n\n\n\n\n\n2.2.1.2 switch\n\nRPython\n\n\nClosely related to if is the switch()-statement. It’s a compact, special purpose equivalent that lets you replace code like:\n\nx_option &lt;- function(x) {\n  if (x == \"a\") {\n    \"option 1\"\n  } else if (x == \"b\") {\n    \"option 2\" \n  } else if (x == \"c\") {\n    \"option 3\"\n  } else {\n    stop(\"Invalid `x` value\")\n  }\n}\n\nwith the more succinct:\n\nx_option &lt;- function(x) {\n  switch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\",\n    stop(\"Invalid `x` value\")\n  )\n}\nx_option(\"b\")\n\n[1] \"option 2\"\n\n\nThe last component of a switch() should always throw an error, otherwise unmatched inputs will invisibly return NULL:\n\n\n\nmatch subject:\n    case &lt;pattern_1&gt;:\n        &lt;action_1&gt;\n    case &lt;pattern_2&gt;:\n        &lt;action_2&gt;\n    case &lt;pattern_3&gt;:\n        &lt;action_3&gt;\n    case _:\n        &lt;action_wildcard&gt;\n\n\ndef x_option(x):\n    options = {\n        \"a\": \"option 1\",\n        \"b\": \"option 2\",\n        \"c\": \"option 3\"\n    }\n    return options.get(x, \"Invalid `x` value\")\n\nprint(x_option(\"b\"))\n\noption 2\n\n\n\n\n\n\n\n2.2.1.3 Vectorised if\n\nRPython\n\n\nGiven that if only works with a single TRUE or FALSE, you might wonder what to do if you have a vector of logical values. Handling vectors of values is the job of ifelse(): a vectorised function with test, yes, and no vectors (that will be recycled to the same length):\n\nx &lt;- 1:10\nifelse(x %% 5 == 0, \"XXX\", as.character(x))\n\n [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n\nifelse(x %% 2 == 0, \"even\", \"odd\")\n\n [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n\n\nNote that missing values will be propagated into the output.\nI recommend using ifelse() only when the yes and no vectors are the same type as it is otherwise hard to predict the output type. See https://vctrs.r-lib.org/articles/stability.html#ifelse for additional discussion.\n\n\n\n\n\n\n\n\n\n2.2.2 Loops\n\n2.2.2.1 for-Loops\nA for loop is used for iterating over a sequence (that is either a list, a tuple, a dictionary, a set, or a string). For each item in vector, perform_action is called once; updating the value of item each time.\n\nRPython\n\n\nIn R, for loops are used to iterate over items in a vector. They have the following basic form:\n\nfor (item in vector) perform_action\n\n\nfor (i in 1:3) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n\n\n\n\n\nfor item in vector \n  perform_action\n\n\nfor i in range(1, 3):\n  print(i)\n\n1\n2\n\n\n\n\n\n\n\n2.2.2.2 while-Loops\nWith the while loop we can execute a set of statements as long as a condition is TRUE:\n\nRPython\n\n\n\ni &lt;- 1\nwhile (i &lt; 6) {\n  print(i)\n  i &lt;- i + 1\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\n\n\n\ni = 1\nwhile i &lt; 6:\n  print(i)\n  i += 1\n\n1\n2\n3\n4\n5\n\n\n\n\n\n\n\n2.2.2.3 terminate\n\nRPython\n\n\nThere are two ways to terminate a for loop early:\n\nnext exits the current iteration.\nbreak exits the entire for loop.\n\n\nfor (i in 1:10) {\n  if (i &lt; 3) \n    next\n\n  print(i)\n  \n  if (i &gt;= 5)\n    break\n}\n\n[1] 3\n[1] 4\n[1] 5\n\n\n\n\n\nfor i in range(1, 10):\n    if i &lt; 3:\n        continue\n    \n    print(i)\n    \n    if i &gt;= 5:\n        break\n\n3\n4\n5"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#function",
    "href": "dataprocess/basic_r_python.html#function",
    "title": "R & Python Basic",
    "section": "2.3 Function",
    "text": "2.3 Function\nMore details of in Advanced R Chapter 6\nA function is a block of code which only runs when it is called. It can be broken down into three components:\n\nThe formals(), the list of arguments that control how you call the function.\nThe body(), the code inside the function.\nThe environment(), the data structure that determines how the function finds the values associated with the names.\n\nWhile the formals and body are specified explicitly when you create a function, the environment is specified implicitly, based on where you defined the function. This location could be within another package or within the workspace (global environment).\n\nRPython\n\n\nThe function environment always exists, but it is only printed when the function isn’t defined in the global environment.\n\nf02 &lt;- function(x, y) {\n  # A comment\n  x + y\n}\n\nformals(f02)\n\n$x\n\n\n$y\n\nbody(f02)\n\n{\n    x + y\n}\n\nenvironment(f02)\n\n&lt;environment: R_GlobalEnv&gt;\n\n\n\n\n\n\n\n\n\n2.3.1 Calling\n\nRPython\n\n\nCalling Syntax:\n\nfunction_name(argument1 = value1, argument2 = value2, ...)\n\nTry using seq(), which makes regular sequences of numbers:\n\nseq(from = 1, to = 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWe often omit the names of the first several arguments in function calls, so we can rewrite this as follows:\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWe can also check the arguments and other information with:\n?seq\nThe “help” windows shows as:\n\n\n\n\nsequence = list(range(1, 11))\nprint(sequence)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n\n\n\n\n\n\n2.3.2 Creating\n\nRPython\n\n\nUse the function() keyword:\n\nmy_add1 &lt;- function(x) {\n  x + 1\n}\n\ncalling the function my_add1:\n\nmy_add1(2)\n\n[1] 3\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn R, the return statement is not essential for a function to yield a value as its result. By default, R will return the result of the last command within the function as its output.\n\n\n\n\nIn Python a function is defined using the def keyword:\n\ndef my_add(x):\n  return x + 1\n\ncalling the function my_add1:\n\nprint(my_add(2))\n\n3\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe return statement is essential for a function to yield a value as its result."
  },
  {
    "objectID": "dataprocess/basic_r_python.html#naming-conventions",
    "href": "dataprocess/basic_r_python.html#naming-conventions",
    "title": "R & Python Basic",
    "section": "3.2 Naming Conventions",
    "text": "3.2 Naming Conventions\n\nCamel Case\n\nEach word, except the first, starts with a capital letter:\nmyVariableName\n\nPascal Case\n\nEach word starts with a capital letter:\nMyVariableName\n\nSnake Case\n\nEach word is separated by an underscore character:\nmy_variable_name"
  }
]