[
  {
    "objectID": "Postprocess/PP_0.html",
    "href": "Postprocess/PP_0.html",
    "title": "Post-Processing",
    "section": "",
    "text": "About this site test1\n\n1 + 1\n\n[1] 2\n\n\n\n\nAbout this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Postprocess/PP_0.html#h2",
    "href": "Postprocess/PP_0.html#h2",
    "title": "Post-Processing",
    "section": "",
    "text": "About this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcom Page",
    "section": "",
    "text": "Welcome to HydroSimul: Your Gateway to Understanding Hydrological Simulation\nWe’re thrilled to have you at HydroSimul, your premier resource for delving into the realm of hydrological simulation. Here, we curate a vast collection of datasets and offer cutting-edge techniques to empower your exploration.\nAt HydroSimul, we believe in the power of collaboration. If you want to share your knowledge, experience, and skills in the field, please contact us at hydro.simul@gmail.com. We also welcome your advice.\nOur website serves as a comprehensive hub for your hydrological journey:"
  },
  {
    "objectID": "index.html#dataset-collection",
    "href": "index.html#dataset-collection",
    "title": "Welcom Page",
    "section": "1. Dataset Collection:",
    "text": "1. Dataset Collection:\nNumerous open-access datasets are readily available for use in hydrological modeling, including meteorological, hydrological, and various geophysical datasets. Within this dataset collection, we not only provide direct links to the datasets but also present essential information in a standardized format, simplifying your dataset selection process. Additionally, we strive to establish connections with research papers that have utilized these datasets and offer valuable feedback gleaned from these sources."
  },
  {
    "objectID": "index.html#data-processing",
    "href": "index.html#data-processing",
    "title": "Welcom Page",
    "section": "2. Data Processing:",
    "text": "2. Data Processing:\nOn this page, we provide you with a wealth of data processing tools and techniques. Discover how to adeptly clean, preprocess, and convert raw hydrological data into a valuable format suitable for analysis and modeling."
  },
  {
    "objectID": "index.html#data-analysis",
    "href": "index.html#data-analysis",
    "title": "Welcom Page",
    "section": "3. Data Analysis:",
    "text": "3. Data Analysis:\nUncover concealed statistical insights and trends within your data. Our comprehensive guides and tutorials are designed to empower you with the skills to effectively analyze hydrological data."
  },
  {
    "objectID": "index.html#hydrological-modeling",
    "href": "index.html#hydrological-modeling",
    "title": "Welcom Page",
    "section": "4. Hydrological Modeling:",
    "text": "4. Hydrological Modeling:\nTake your understanding to the next level with hydrological modeling. Explore various models and model frameworks and acquire hands-on experience in simulating complex hydrological processes. Additionally, we provide extensive resources on calibration algorithms and strategies to significantly improve your modeling outcomes."
  },
  {
    "objectID": "dataset/index.html",
    "href": "dataset/index.html",
    "title": "Dataset",
    "section": "",
    "text": "Numerous open-access datasets are readily available for use in hydrological modeling, including meteorological, hydrological, and various geophysical datasets. Within this dataset collection, we not only provide direct links to the datasets but also present essential information in a standardized format, simplifying your dataset selection process. Additionally, we strive to establish connections with research papers that have utilized these datasets and offer valuable feedback gleaned from these sources."
  },
  {
    "objectID": "dataset/geoph.html",
    "href": "dataset/geoph.html",
    "title": "Geophysical",
    "section": "",
    "text": "About this site test1\n\n1 + 1\n\n[1] 2\n\n\n\n\nAbout this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataset/geoph.html#h2",
    "href": "dataset/geoph.html#h2",
    "title": "Geophysical",
    "section": "",
    "text": "About this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataprocess/NetCDF.html",
    "href": "dataprocess/NetCDF.html",
    "title": "NetCDF",
    "section": "",
    "text": "About this site test1\n\n1 + 1\n\n[1] 2\n\n\n\n\nAbout this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataprocess/NetCDF.html#h2",
    "href": "dataprocess/NetCDF.html#h2",
    "title": "NetCDF",
    "section": "",
    "text": "About this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataprocess/basic_format.html",
    "href": "dataprocess/basic_format.html",
    "title": "Basic format",
    "section": "",
    "text": "In hydrological modeling, various data formats are used to represent and manage different types of data. The choice of data format depends on the nature of the data, the modeling software being used, and specific project requirements. Here are some common data formats used in hydrological modeling, along with their key features:"
  },
  {
    "objectID": "dataprocess/basic_format.html#ascii",
    "href": "dataprocess/basic_format.html#ascii",
    "title": "Basic format",
    "section": "ASCII",
    "text": "ASCII\nASCII (American Standard Code for Information Interchange) is a plain text format, making it human-readable.\n\nAdvantages\n\nHuman-Readable: Users can easily view, understand, and edit the data directly in a text editor.\nWidespread Support, Ease of Import/Export: ASCII is universally supported. Most programming languages, data analysis tools, and software applications can read and write ASCII files, ensuring high compatibility.\nLightweight: ASCII files are typically lightweight and do not consume excessive storage space, making them suitable for large datasets.\nSimple Structure: ASCII files have a straightforward structure, often using lines of text with fields separated by delimiters. This simplicity aids in data extraction and manipulation.\n\n\n\nDisadvantages\n\nLimited Data Types: ASCII primarily handles text-based data and is not suitable for complex data types such as images, multimedia, or hierarchical data.\nNo Inherent Data Validation: ASCII files lack built-in mechanisms for data validation or integrity checks, requiring users to ensure data conformity.\nLack of Compression: ASCII files do not inherently support data compression, potentially resulting in larger file sizes compared to binary formats.\nLimited Metadata: ASCII format lacks standardized metadata structures common in other formats, making comprehensive data documentation challenging.\nSlower Reading/Writing: Reading and writing data in ASCII format may be slower, especially for large datasets, due to additional parsing required to interpret text-based data.\n\n\n\nfile format for ASCII data\n\n.txt: This is the most generic and widely used file extension for plain text files. It doesn’t imply any specific format or structure; it’s just a simple text file.\n.csv (Comma-Separated Values): While CSV files contain data separated by commas, they are still considered ASCII files because they use plain text characters to represent data values. Each line in a CSV file typically represents a record, with values separated by commas."
  },
  {
    "objectID": "dataprocess/basic_format.html#binary",
    "href": "dataprocess/basic_format.html#binary",
    "title": "Basic format",
    "section": "Binary",
    "text": "Binary\n\nAdvantages of Binary Formats\n\nEfficiency: Binary formats are highly efficient for data storage and transmission because they represent data in a compact binary form. This can significantly reduce storage space and data transfer times, making them ideal for large datasets.\nData Integrity: Binary formats often include built-in mechanisms for data integrity and error checking. This helps ensure that data remains intact and accurate during storage and transmission.\nComplex Data: Binary formats can represent complex data structures, including images, multimedia, and hierarchical data, in a way that maintains data integrity and structure. This makes them suitable for a wide range of data types.\nFaster I/O: Reading and writing data in binary format is generally faster than text-based formats like ASCII. This efficiency is particularly important for applications that require high-speed data processing.\nSecurity: Binary formats can provide a level of data security because they are not easily human-readable. This can be advantageous when dealing with sensitive information.\n\n\n\nDisadvantages of Binary Formats\n\nLack of Human-Readability: Binary formats are not human-readable, making it difficult to view or edit the data directly. This can be a disadvantage when data inspection or manual editing is required.\nCompatibility: Binary formats may not be universally compatible across different software platforms and programming languages. This can lead to issues when sharing or accessing data in various environments.\nLimited Metadata: Binary formats may not include comprehensive metadata structures, making it challenging to document and describe the data effectively.\nVersion Compatibility: Changes in the binary format’s structure or encoding can lead to compatibility issues when working with data created using different versions of software or hardware.\nDebugging and Troubleshooting: Debugging and troubleshooting binary data can be more challenging compared to human-readable formats like ASCII. Detecting and resolving issues may require specialized tools and expertise.\nPlatform Dependence: Binary formats can be platform-dependent, meaning they may not be easily transferable between different operating systems or hardware architectures.\n\nBinary formats are a valuable choice for certain applications, particularly when efficiency, data integrity, and complex data types are crucial. However, they may not be suitable for all scenarios, especially when human readability, compatibility, or ease of data inspection is essential.\n\n\nNectCDF\nNetCDF (Network Common Data Form) is a versatile data format widely used in scientific and environmental applications. It is primarily a binary data format, but it includes structured elements for efficient data storage and management. Here are some key characteristics of NetCDF:\n\nBinary Representation: NetCDF data files are primarily stored in binary format, which enables efficient storage and handling of numerical data, particularly floating-point numbers.\nSelf-Describing: NetCDF files are self-describing, meaning they include metadata alongside the data. This metadata provides essential information about the data’s structure, dimensions, units, and other attributes.\nHierarchical Structure: NetCDF supports a hierarchical structure capable of representing complex data types, including multi-dimensional arrays and groups of data variables.\nData Compression: NetCDF allows for data compression, which can reduce the storage space required for large datasets while maintaining data integrity.\nPlatform-Independent: NetCDF files are designed to be platform-independent, ensuring compatibility across various operating systems and hardware architectures.\nLanguage Support: NetCDF libraries and tools are available for multiple programming languages, making it accessible to a wide range of scientific and data analysis applications.\n\nNetCDF’s combination of binary efficiency and structured metadata makes it an invaluable choice for storing and sharing scientific data, particularly in fields such as meteorology, oceanography, and environmental science.\n\n\nOther row data from"
  },
  {
    "objectID": "dataprocess/index.html",
    "href": "dataprocess/index.html",
    "title": "Dataset",
    "section": "",
    "text": "Numerous open-access datasets are readily available for use in hydrological modeling, including meteorological, hydrological, and various geophysical datasets. Within this dataset collection, we not only provide direct links to the datasets but also present essential information in a standardized format, simplifying your dataset selection process. Additionally, we strive to establish connections with research papers that have utilized these datasets and offer valuable feedback gleaned from these sources."
  },
  {
    "objectID": "dataprocess/spatial_data.html",
    "href": "dataprocess/spatial_data.html",
    "title": "spatial data",
    "section": "",
    "text": "About this site test1\n\n1 + 1\n\n[1] 2\n\n\n\n\nAbout this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataprocess/spatial_data.html#h2",
    "href": "dataprocess/spatial_data.html#h2",
    "title": "spatial data",
    "section": "",
    "text": "About this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataset/hydro.html",
    "href": "dataset/hydro.html",
    "title": "Hydro",
    "section": "",
    "text": "About this site test1\n\n1 + 1\n\n[1] 2\n\n\n\n\nAbout this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataset/hydro.html#h2",
    "href": "dataset/hydro.html#h2",
    "title": "Hydro",
    "section": "",
    "text": "About this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataset/meteo.html",
    "href": "dataset/meteo.html",
    "title": "Meteological",
    "section": "",
    "text": "About this site test1\n\n1 + 1\n\n[1] 2\n\n\n\n\nAbout this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataset/meteo.html#h2",
    "href": "dataset/meteo.html#h2",
    "title": "Meteological",
    "section": "",
    "text": "About this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Modelling/HM_0.html",
    "href": "Modelling/HM_0.html",
    "title": "Modelling",
    "section": "",
    "text": "About this site test1\n\n1 + 1\n\n[1] 2\n\n\n\n\nAbout this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Modelling/HM_0.html#h2",
    "href": "Modelling/HM_0.html#h2",
    "title": "Modelling",
    "section": "",
    "text": "About this site test2\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "dataprocess/data_workspace.html",
    "href": "dataprocess/data_workspace.html",
    "title": "Data in Workspace",
    "section": "",
    "text": "More Details in R for Data Science (2e)"
  },
  {
    "objectID": "dataprocess/data_workspace.html#coding-basics",
    "href": "dataprocess/data_workspace.html#coding-basics",
    "title": "Data in Workspace",
    "section": "Coding basics",
    "text": "Coding basics\n\nmath calculations:\n\n‘+’\n‘-’\n’*’\n‘/’\nTrigonometric functions\n\n\nRPython\n\n\n\n1 / 200 * 30\n\n[1] 0.15\n\n(59 + 73 - 2) / 3\n\n[1] 43.33333\n\n3^2\n\n[1] 9\n\nsin(pi / 2) # pi as Const number in R\n\n[1] 1\n\n\n\n\n\n\n\n\n\n\nCreate new objects\n\nRPython\n\n\nCreate new objects with the assignment operator &lt;-:\n\n# \"&lt;-\" special in R \n\na &lt;- 1 / 200 * 30\nb &lt;- a + 1\n\n\n\n\n\n\n\n\n\nNaming rules\n\nRPython\n\n\n\nmust start with a letter\ncan only contain letters, numbers, underscores _, and dot .\ncase-sensitive (age, Age and AGE are three different variables)\ncannot be any of the Reserved Words\n\nTRUE FALSE\nNULL Inf NaN NA NA_real NA_complex_ NA_character_\nif else\nfor while repeat\nnext break\nfunction\nin\n\n\n\n\n\n\n\n\n\n\nLegal\n\n\n\ni_use_snake_case\notherPeopleUseCamelCase\nsome.people.use.periods\naFew.People_RENOUNCEconvention6\n\n\n\n\n\n\n\n\n\n\n\nIllegal\n\n\n\n_start_with_underscores\n1_start_with_number\nif\ncontain sapce\ncontain-other+charater\n\n\n\n\nmore Reserved Words in:\nhelp(\"reserved\")\n\n\n\nmust start with a letter or the underscore character _\ncan only contain letters, numbers, and underscores _\ncase-sensitive (age, Age and AGE are three different variables)\ncannot be any of the Python keywords (35 keywors in Python 3.8)\n\nTrue False\nNone\nif else elif\nfor while repeat\ntry break continue finally\ndef\nin and or not\nreturn\n\n\n\n\n\n\n\n\n\n\nLegal\n\n\n\ni_use_snake_case\n_start_with_underscores\notherPeopleUseCamelCase\naFew_People_RENOUNCEconvention6\n\n\n\n\n\n\n\n\n\n\n\nIllegal\n\n\n\nwant.contain.dot\n1_start_with_number\nif\ncontain sapce\ncontain-other+charater\n\n\n\n\nMore Keywords in:\n&gt;&gt;&gt; help(\"keywords\")\n\n\n\n\nProgramming Naming Conventions\n\nCamel Case\n\nEach word, except the first, starts with a capital letter:\nmyVariableName\n\nPascal Case\n\nEach word starts with a capital letter:\nMyVariableName\n\nSnake Case\n\nEach word is separated by an underscore character:\nmy_variable_name"
  },
  {
    "objectID": "dataprocess/data_workspace.html#function",
    "href": "dataprocess/data_workspace.html#function",
    "title": "Data in Workspace",
    "section": "Function",
    "text": "Function\n\nCalling\n\nRPython\n\n\nCalling Syntax:\n\nfunction_name(argument1 = value1, argument2 = value2, ...)\n\nWe can also check the arguments and other information with:\n?seq\nTry using seq(), which makes regular sequences of numbers:\n\nseq(from = 1, to = 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWe often omit the names of the first several arguments in function calls, so we can rewrite this as follows:\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10"
  },
  {
    "objectID": "dataprocess/basic_r_python.html",
    "href": "dataprocess/basic_r_python.html",
    "title": "R & Python Basic",
    "section": "",
    "text": "More Details of R in R for Data Science (2e) and Advanced R\nMore Details of Python in Automate the Boring Stuff with Python and W3 School Python\nThis article serves as a brief introduction to the fundamental coding aspects of both R and Python. It provides a first impression of these scripting languages. For a more comprehensive understanding and in-depth techniques related to both languages, you are encouraged to explore the website mentioned above. The content here is primarily a condensed compilation of information from the provided links, aimed at facilitating a comparison between R and Python.\nData and Functions are the two essential components of every programming language, especially in the context of data science and data processing. They can be likened to nouns and verbs in natural languages. Data describes information, while Functions define actions for manipulating that data.\nThis article is divided into two main sections: Data (Section 1) and Coding (Section 2).\nIn the Data section, we will explore:\nIn the Coding section, we will delve into three key aspects:\nThe above five elements can be considered as the most fundamental elements of every scripting language. Additionally, we will explore object creation and naming in a section called ‘New Objects’ (Section 3). Objects can encompass functions and variables, further enriching our understanding of scripting.\nThis article will provide a solid introduction to the core concepts in programming, laying the groundwork for further exploration in both R and Python."
  },
  {
    "objectID": "dataprocess/basic_r_python.html#naming-rules",
    "href": "dataprocess/basic_r_python.html#naming-rules",
    "title": "R & Python Basic",
    "section": "3.1 Naming rules",
    "text": "3.1 Naming rules\n\nRPython\n\n\n\nmust start with a letter\ncan only contain letters, numbers, underscores _, and dot .\ncase-sensitive (age, Age and AGE are three different variables)\ncannot be any of the Reserved Words\n\nTRUE FALSE\nNULL Inf NaN NA NA_real NA_complex_ NA_character_\nif else\nfor while repeat\nnext break\nfunction\nin\n\n\n\n\n\n\n\n\n\n\nLegal\n\n\n\ni_use_snake_case\notherPeopleUseCamelCase\nsome.people.use.periods\naFew.People_RENOUNCEconvention6\n\n\n\n\n\n\n\n\n\n\n\nIllegal\n\n\n\n_start_with_underscores\n1_start_with_number\nif\ncontain sapce\ncontain-other+charater\n\n\n\n\nmore Reserved Words in:\nhelp(\"reserved\")\n\n\n\nmust start with a letter or the underscore character _\ncan only contain letters, numbers, and underscores _\ncase-sensitive (age, Age and AGE are three different variables)\ncannot be any of the Python keywords (35 keywors in Python 3.8)\n\nTrue False\nNone\nif else elif\nfor while repeat\ntry break continue finally\ndef\nin and or not\nreturn\n\n\n\n\n\n\n\n\n\n\nLegal\n\n\n\ni_use_snake_case\n_start_with_underscores\notherPeopleUseCamelCase\naFew_People_RENOUNCEconvention6\n\n\n\n\n\n\n\n\n\n\n\nIllegal\n\n\n\nwant.contain.dot\n1_start_with_number\nif\ncontain sapce\ncontain-other+charater\n\n\n\n\nMore Keywords in:\n\nhelp(\"keywords\")"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#programming-naming-conventions",
    "href": "dataprocess/basic_r_python.html#programming-naming-conventions",
    "title": "R & Python Basic",
    "section": "3.2 Programming Naming Conventions",
    "text": "3.2 Programming Naming Conventions\n\nCamel Case\n\nEach word, except the first, starts with a capital letter:\nmyVariableName\n\nPascal Case\n\nEach word starts with a capital letter:\nMyVariableName\n\nSnake Case\n\nEach word is separated by an underscore character:\nmy_variable_name"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#calling",
    "href": "dataprocess/basic_r_python.html#calling",
    "title": "Coding basics",
    "section": "Calling",
    "text": "Calling\n\nRPython\n\n\nCalling Syntax:\n\nfunction_name(argument1 = value1, argument2 = value2, ...)\n\nTry using seq(), which makes regular sequences of numbers:\n\nseq(from = 1, to = 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWe often omit the names of the first several arguments in function calls, so we can rewrite this as follows:\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWe can also check the arguments and other information with:\n?seq\nThe “help” windows shows as:\n\n\n\n\nsequence = list(range(1, 11))\nprint(sequence)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#define",
    "href": "dataprocess/basic_r_python.html#define",
    "title": "Coding basics",
    "section": "Define",
    "text": "Define\n\nRPython\n\n\nuse the function() keyword:\n\nmy_add1 &lt;- function(x) { # create a function with the name my_function\n  x + 1\n}\n\ncalling the function my_add1:\n\nmy_add1(2)\n\n[1] 3"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#choices",
    "href": "dataprocess/basic_r_python.html#choices",
    "title": "Coding basics",
    "section": "choices",
    "text": "choices\n\nBasic If-Else\n\nRPython\n\n\nThe basic form of an if statement in R is as follows:\n\nif (condition) true_action\nif (condition) true_action else false_action\n\nIf condition is TRUE, true_action is evaluated; if condition is FALSE, the optional false_action is evaluated.\nTypically the actions are compound statements contained within {:\nif returns a value so that you can assign the results:\n\na &lt;- 6\nb &lt;- 8\n\nif (b &gt; a) {\n  cat(\"b is greater than a\\n\")\n} else if (a == b) {\n  cat(\"a and b are equal\\n\")\n} else {\n  cat(\"a is greater than b\\n\")\n}\n\nb is greater than a\n\n\n\n\n\n# if statements\nif condition: \n  true_action\n  \n# if-else\nif condition: \n  true_action \nelse: \n  false_action\n\n\n# if-ifel-else\nif condition1: \n  true_action1 \nelif condition2: \n  true_action2 \nelse: \n  false_action\n\n\na = 6\nb = 8\nif b &gt; a:\n  print(\"b is greater than a\")\nelif a == b:\n  print(\"a and b are equal\")\nelse:\n  print(\"a is greater than b\")\n\nb is greater than a\n\n\n\n\n\n\n\nswitch\n\nRPython\n\n\nClosely related to if is the switch()-statement. It’s a compact, special purpose equivalent that lets you replace code like:\n\nx_option &lt;- function(x) {\n  if (x == \"a\") {\n    \"option 1\"\n  } else if (x == \"b\") {\n    \"option 2\" \n  } else if (x == \"c\") {\n    \"option 3\"\n  } else {\n    stop(\"Invalid `x` value\")\n  }\n}\n\nwith the more succinct:\n\nx_option &lt;- function(x) {\n  switch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\",\n    stop(\"Invalid `x` value\")\n  )\n}\nx_option(\"b\")\n\n[1] \"option 2\"\n\n\nThe last component of a switch() should always throw an error, otherwise unmatched inputs will invisibly return NULL:\n\n\n\nmatch subject:\n    case &lt;pattern_1&gt;:\n        &lt;action_1&gt;\n    case &lt;pattern_2&gt;:\n        &lt;action_2&gt;\n    case &lt;pattern_3&gt;:\n        &lt;action_3&gt;\n    case _:\n        &lt;action_wildcard&gt;\n\n\ndef x_option(x):\n    options = {\n        \"a\": \"option 1\",\n        \"b\": \"option 2\",\n        \"c\": \"option 3\"\n    }\n    return options.get(x, \"Invalid `x` value\")\n\nprint(x_option(\"b\"))\n\noption 2\n\n\n\n\n\n\n\nVectorised if\n\nRPython\n\n\nGiven that if only works with a single TRUE or FALSE, you might wonder what to do if you have a vector of logical values. Handling vectors of values is the job of ifelse(): a vectorised function with test, yes, and no vectors (that will be recycled to the same length):\n\nx &lt;- 1:10\nifelse(x %% 5 == 0, \"XXX\", as.character(x))\n\n [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n\nifelse(x %% 2 == 0, \"even\", \"odd\")\n\n [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n\n\nNote that missing values will be propagated into the output.\nI recommend using ifelse() only when the yes and no vectors are the same type as it is otherwise hard to predict the output type. See https://vctrs.r-lib.org/articles/stability.html#ifelse for additional discussion."
  },
  {
    "objectID": "dataprocess/basic_r_python.html#loops",
    "href": "dataprocess/basic_r_python.html#loops",
    "title": "Coding basics",
    "section": "Loops",
    "text": "Loops\n\nfor-Loops\nA for loop is used for iterating over a sequence (that is either a list, a tuple, a dictionary, a set, or a string). For each item in vector, perform_action is called once; updating the value of item each time.\n\nRPython\n\n\nIn R, for loops are used to iterate over items in a vector. They have the following basic form:\n\nfor (item in vector) perform_action\n\n\nfor (i in 1:3) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n\n\n\n\n\nfor item in vector \n  perform_action\n\n\nfor i in range(1, 3):\n  print(i)\n\n1\n2\n\n\n\n\n\n\n\nwhile-Loops\nWith the while loop we can execute a set of statements as long as a condition is TRUE:\n\nRPython\n\n\n\ni &lt;- 1\nwhile (i &lt; 6) {\n  print(i)\n  i &lt;- i + 1\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\n\n\n\ni = 1\nwhile i &lt; 6:\n  print(i)\n  i += 1\n\n1\n2\n3\n4\n5\n\n\n\n\n\n\n\nterminate\n\nRPython\n\n\nThere are two ways to terminate a for loop early:\n\nnext exits the current iteration.\nbreak exits the entire for loop.\n\n\nfor (i in 1:10) {\n  if (i &lt; 3) \n    next\n\n  print(i)\n  \n  if (i &gt;= 5)\n    break\n}\n\n[1] 3\n[1] 4\n[1] 5\n\n\n\n\n\nfor i in range(1, 10):\n    if i &lt; 3:\n        continue\n    \n    print(i)\n    \n    if i &gt;= 5:\n        break\n\n3\n4\n5"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#creating",
    "href": "dataprocess/basic_r_python.html#creating",
    "title": "Coding basics",
    "section": "Creating",
    "text": "Creating\n\nRPython\n\n\nUse the function() keyword:\n\nmy_add1 &lt;- function(x) {\n  x + 1\n}\n\ncalling the function my_add1:\n\nmy_add1(2)\n\n[1] 3\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn R, the return statement is not essential for a function to yield a value as its result. By default, R will return the result of the last command within the function as its output.\n\n\n\n\nIn Python a function is defined using the def keyword:\n\ndef my_add(x):\n  return x + 1\n\ncalling the function my_add1:\n\nprint(my_add(2))\n\n3\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe return statement is essential for a function to yield a value as its result."
  },
  {
    "objectID": "dataprocess/basic_r_python.html#datatype",
    "href": "dataprocess/basic_r_python.html#datatype",
    "title": "R & Python Basic",
    "section": "1.1 Datatype",
    "text": "1.1 Datatype\nA data type of a variable specifies the type of data that is stored inside that variable. In this context, we will just discuss Atomic Variables, which represent fundamental data types. There are six basic atomic data types:\n\nLogical (boolean data type)\n\ncan only have two values: TRUE and FALSE\n\nNumeric (double, float, lang)\n\nrepresents all real numbers with or without decimal values.\n\nInteger\n\nspecifies real values without decimal points.\n\nComplex\n\nis used to specify purely imaginary values\n\nCharacter (string)\n\ndata type is used to specify character or string values in a variable\n\nRaw (bytes)\n\nspecifies values as raw bytes\n\n\n\nRPython\n\n\nIn R, variables do not require explicit declaration with a particular data type. Instead, R is dynamically typed, allowing variables to adapt to the data they contain. You can use the following techniques to work with data types in R:\n\nChecking Data Types: To determine the data type of a variable, you can use the class() function.\nType Conversion: When needed, you can change the data type of a variable using R’s conversion functions, typically prefixed with as..\n\nR’s flexibility in data type handling simplifies programming tasks and allows for efficient data manipulation without the need for explicit type declarations.\n\n# Numeric\nx &lt;- 10.5\nclass(x)\n\n[1] \"numeric\"\n\n# Integer\nx &lt;- 1000L\nclass(x)\n\n[1] \"integer\"\n\n# Complex\nx &lt;- 9i + 3\nclass(x)\n\n[1] \"complex\"\n\n# Character/String\nx &lt;- \"R is exciting\"\nclass(x)\n\n[1] \"character\"\n\n# Logical/Boolean\nx &lt;- TRUE\nclass(x)\n\n[1] \"logical\"\n\n# Convert\ny &lt;- as.numeric(x)\nclass(y)\n\n[1] \"numeric\"\n\n# Raw (bytes)\nx &lt;- charToRaw(\"A\")\nx\n\n[1] 41\n\nclass(x)\n\n[1] \"raw\"\n\n\n\n\nIn Python, variables also do not require explicit declaration with a particular data type. Python is dynamically typed, allowing variables to adapt to the data they contain. You can use the following techniques to work with data types in Python:\n\nChecking Data Types: To determine the data type of a variable, you can use the type() function. It allows you to inspect the current data type of a variable.\nType Conversion: When needed, you can change the data type of a variable in Python using various conversion functions, like float().\n\nPython’s flexibility in data type handling simplifies programming tasks and allows for efficient data manipulation without the need for explicit type declarations.\n\n# Numeric\nx = 10.5\nprint(type(x))\n\n&lt;class 'float'&gt;\n\n# Integer\nx = 1000\nprint(type(x))\n\n&lt;class 'int'&gt;\n\n# Complex\nx = 9j + 3\nprint(type(x))\n\n&lt;class 'complex'&gt;\n\n# Character/String\nx = \"Python is exciting\"\nprint(type(x))\n\n&lt;class 'str'&gt;\n\n# Logical/Boolean\nx = True\nprint(type(x))\n\n&lt;class 'bool'&gt;\n\n# Convert to Numeric\ny = float(x)\nprint(type(y))\n\n&lt;class 'float'&gt;\n\n# Raw (bytes)\nx = b'A'\nprint(x)\n\nb'A'\n\nprint(type(x))\n\n&lt;class 'bytes'&gt;"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#data-structure",
    "href": "dataprocess/basic_r_python.html#data-structure",
    "title": "R & Python Basic",
    "section": "1.2 Data Structure",
    "text": "1.2 Data Structure\nComparatively, data structures between R and Python tend to exhibit more differences than their data types. However, by incorporating additional libraries like NumPy and pandas, we can access shared data structures which play a vital role in the field of data science.\n\nVector: A set of multiple values (items)\n\nContains items of the same data type or structure\nIndexed: Allows you to get and change items using indices\nAllows duplicates\nChangeable: You can modify, add, and remove items after creation\n\nArray: A multi-dimensional extension of a vector\n\nMatrix: two dimensions\n\nList: A set of multiple values (items)\n\nContains items of different data types or structures\nIndexed: Allows you to get and change items using indices\nAllows duplicates\nChangeable: You can modify, add, and remove items after creation\n\nTable (Data Frame): Tabular data structure\n\nTwo-dimensional objects with rows and columns\nContains elements of several types\nEach column has the same data type\n\n\n\nRPython\n\n\nThe structure of R variable can be checked with str()ucture:\n\n# Create a vector\nvct_Test &lt;- c(1,5,7)\n# View the structure\nstr(vct_Test)\n\n num [1:3] 1 5 7\n\n# Create a array\nary_Test &lt;- array(1:24, c(2,3,4))\n# View the structure\nstr(ary_Test)\n\n int [1:2, 1:3, 1:4] 1 2 3 4 5 6 7 8 9 10 ...\n\n# Create a matrix\nmat_Test &lt;- matrix(1:24, 6, 4)\nmat_Test\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    7   13   19\n[2,]    2    8   14   20\n[3,]    3    9   15   21\n[4,]    4   10   16   22\n[5,]    5   11   17   23\n[6,]    6   12   18   24\n\n# View the structure\nstr(mat_Test)\n\n int [1:6, 1:4] 1 2 3 4 5 6 7 8 9 10 ...\n\n# Create a list\nlst_Test &lt;- list(c(1,3,5), \"abc\", FALSE)\n# View the structure\nstr(lst_Test)\n\nList of 3\n $ : num [1:3] 1 3 5\n $ : chr \"abc\"\n $ : logi FALSE\n\n# Create a table (data frame)\ndf_Test &lt;- data.frame(name = c(\"Bob\", \"Tom\"), age = c(12, 13))\ndf_Test\n\n  name age\n1  Bob  12\n2  Tom  13\n\n# View the structure\nstr(df_Test)\n\n'data.frame':   2 obs. of  2 variables:\n $ name: chr  \"Bob\" \"Tom\"\n $ age : num  12 13\n\n\n\n\nIn Python, the structure of a variable is treated as the data type, and you can confirm it using the type() function.\nIt’s important to note that some of the most commonly used data structures, such as arrays and data frames (tables), are not part of the core Python language itself. Instead, they are provided by two popular libraries: numpy and pandas.\n\nimport numpy as np\nimport pandas as pd\n\n# Create a vector (list in Python)\nvct_Test = [1, 5, 7]\n# View the structure\nprint(type(vct_Test))\n\n&lt;class 'list'&gt;\n\n# Create a 3D array (NumPy ndarray)\nary_Test = np.arange(1, 25).reshape((2, 3, 4))\n# View the structure\nprint(type(ary_Test))\n\n&lt;class 'numpy.ndarray'&gt;\n\n# Create a matrix (NumPy ndarray)\nmat_Test = np.arange(1, 25).reshape((6, 4))\nprint(type(mat_Test))\n\n&lt;class 'numpy.ndarray'&gt;\n\n# Create a list\nlst_Test = [[1, 3, 5], \"abc\", False]\n# View the structure\nprint(type(lst_Test))\n\n&lt;class 'list'&gt;\n\n# Create a table (pandas DataFrame)\ndf_Test = pd.DataFrame({\"name\": [\"Bob\", \"Tom\"], \"age\": [12, 13]})\nprint(type(df_Test))\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\n\nprint(df_Test)\n\n  name  age\n0  Bob   12\n1  Tom   13\n\n\nPython offers several original data structures, including:\n\nTuples: Tuples are ordered collections of elements, similar to lists, but unlike lists, they are immutable, meaning their elements cannot be changed after creation. Tuples are often used to represent fixed collections of items.\nSets: Sets are unordered collections of unique elements. They are valuable for operations that require uniqueness, such as finding unique values in a dataset or performing set-based operations like unions and intersections.\nDictionaries: Dictionaries, also known as dicts, are collections of key-value pairs. They are used to store data in a structured and efficient manner, allowing quick access to values using their associated keys.\n\nWhile these data structures may not be as commonly used in data manipulation and calculations as arrays and data frames, they have unique features and use cases that can be valuable in various programming scenarios."
  },
  {
    "objectID": "dataprocess/basic_r_python.html#math-calculations",
    "href": "dataprocess/basic_r_python.html#math-calculations",
    "title": "R & Python Basic",
    "section": "2.1 math calculations",
    "text": "2.1 math calculations\n\n‘+’ ‘-’ ’*’ ‘/’\nExponent, Logarithm\nTrigonometric functions\nLinear algebra, Matrix multiplication\n\n\nRPython\n\n\n\n1 / 200 * 30\n\n[1] 0.15\n\n(59 + 73 - 2) / 3\n\n[1] 43.33333\n\n3^2\n\n[1] 9\n\nsin(pi / 2) # pi as Const number in R\n\n[1] 1\n\n\n\n\n\nprint(1 / 200 * 30)\n\n0.15\n\nprint((59 + 73 - 2) / 3)\n\n43.333333333333336\n\nprint(3**2)\n\n9\n\nimport math\nprint(math.sin(math.pi/2))\n\n1.0"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#control-flow",
    "href": "dataprocess/basic_r_python.html#control-flow",
    "title": "R & Python Basic",
    "section": "2.2 Control flow",
    "text": "2.2 Control flow\nThere are two primary tools of control flow: choices and loops.\n\nChoices, like if statements calls, allow you to run different code depending on the input.\nLoops, like for and while, allow you to repeatedly run code, typically with changing options.\n\n\n2.2.1 choices\n\n2.2.1.1 Basic If-Else\n\nRPython\n\n\nThe basic form of an if statement in R is as follows:\n\nif (condition) true_action\nif (condition) true_action else false_action\n\nIf condition is TRUE, true_action is evaluated; if condition is FALSE, the optional false_action is evaluated.\nTypically the actions are compound statements contained within {:\nif returns a value so that you can assign the results:\n\na &lt;- 6\nb &lt;- 8\n\nif (b &gt; a) {\n  cat(\"b is greater than a\\n\")\n} else if (a == b) {\n  cat(\"a and b are equal\\n\")\n} else {\n  cat(\"a is greater than b\\n\")\n}\n\nb is greater than a\n\n\n\n\n\n# if statements\nif condition: \n  true_action\n  \n# if-else\nif condition: \n  true_action \nelse: \n  false_action\n\n\n# if-ifel-else\nif condition1: \n  true_action1 \nelif condition2: \n  true_action2 \nelse: \n  false_action\n\n\na = 6\nb = 8\nif b &gt; a:\n  print(\"b is greater than a\")\nelif a == b:\n  print(\"a and b are equal\")\nelse:\n  print(\"a is greater than b\")\n\nb is greater than a\n\n\n\n\n\n\n\n2.2.1.2 switch\n\nRPython\n\n\nClosely related to if is the switch()-statement. It’s a compact, special purpose equivalent that lets you replace code like:\n\nx_option &lt;- function(x) {\n  if (x == \"a\") {\n    \"option 1\"\n  } else if (x == \"b\") {\n    \"option 2\" \n  } else if (x == \"c\") {\n    \"option 3\"\n  } else {\n    stop(\"Invalid `x` value\")\n  }\n}\n\nwith the more succinct:\n\nx_option &lt;- function(x) {\n  switch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\",\n    stop(\"Invalid `x` value\")\n  )\n}\nx_option(\"b\")\n\n[1] \"option 2\"\n\n\nThe last component of a switch() should always throw an error, otherwise unmatched inputs will invisibly return NULL:\n\n\n\nmatch subject:\n    case &lt;pattern_1&gt;:\n        &lt;action_1&gt;\n    case &lt;pattern_2&gt;:\n        &lt;action_2&gt;\n    case &lt;pattern_3&gt;:\n        &lt;action_3&gt;\n    case _:\n        &lt;action_wildcard&gt;\n\n\ndef x_option(x):\n    options = {\n        \"a\": \"option 1\",\n        \"b\": \"option 2\",\n        \"c\": \"option 3\"\n    }\n    return options.get(x, \"Invalid `x` value\")\n\nprint(x_option(\"b\"))\n\noption 2\n\n\n\n\n\n\n\n2.2.1.3 Vectorised if\n\nRPython\n\n\nGiven that if only works with a single TRUE or FALSE, you might wonder what to do if you have a vector of logical values. Handling vectors of values is the job of ifelse(): a vectorised function with test, yes, and no vectors (that will be recycled to the same length):\n\nx &lt;- 1:10\nifelse(x %% 5 == 0, \"XXX\", as.character(x))\n\n [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n\nifelse(x %% 2 == 0, \"even\", \"odd\")\n\n [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n\n\nNote that missing values will be propagated into the output.\nI recommend using ifelse() only when the yes and no vectors are the same type as it is otherwise hard to predict the output type. See https://vctrs.r-lib.org/articles/stability.html#ifelse for additional discussion.\n\n\n\n\n\n\n\n\n\n2.2.2 Loops\n\n2.2.2.1 for-Loops\nA for loop is used for iterating over a sequence (that is either a list, a tuple, a dictionary, a set, or a string). For each item in vector, perform_action is called once; updating the value of item each time.\n\nRPython\n\n\nIn R, for loops are used to iterate over items in a vector. They have the following basic form:\n\nfor (item in vector) perform_action\n\n\nfor (i in 1:3) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n\n\n\n\n\nfor item in vector \n  perform_action\n\n\nfor i in range(1, 3):\n  print(i)\n\n1\n2\n\n\n\n\n\n\n\n2.2.2.2 while-Loops\nWith the while loop we can execute a set of statements as long as a condition is TRUE:\n\nRPython\n\n\n\ni &lt;- 1\nwhile (i &lt; 6) {\n  print(i)\n  i &lt;- i + 1\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\n\n\n\ni = 1\nwhile i &lt; 6:\n  print(i)\n  i += 1\n\n1\n2\n3\n4\n5\n\n\n\n\n\n\n\n2.2.2.3 terminate\n\nRPython\n\n\nThere are two ways to terminate a for loop early:\n\nnext exits the current iteration.\nbreak exits the entire for loop.\n\n\nfor (i in 1:10) {\n  if (i &lt; 3) \n    next\n\n  print(i)\n  \n  if (i &gt;= 5)\n    break\n}\n\n[1] 3\n[1] 4\n[1] 5\n\n\n\n\n\nfor i in range(1, 10):\n    if i &lt; 3:\n        continue\n    \n    print(i)\n    \n    if i &gt;= 5:\n        break\n\n3\n4\n5"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#function",
    "href": "dataprocess/basic_r_python.html#function",
    "title": "R & Python Basic",
    "section": "2.3 Function",
    "text": "2.3 Function\nMore details of in Advanced R Chapter 6\nA function is a block of code which only runs when it is called. It can be broken down into three components:\n\nThe formals(), the list of arguments that control how you call the function.\nThe body(), the code inside the function.\nThe environment(), the data structure that determines how the function finds the values associated with the names.\n\nWhile the formals and body are specified explicitly when you create a function, the environment is specified implicitly, based on where you defined the function. This location could be within another package or within the workspace (global environment).\n\nRPython\n\n\nThe function environment always exists, but it is only printed when the function isn’t defined in the global environment.\n\nf02 &lt;- function(x, y) {\n  # A comment\n  x + y\n}\n\nformals(f02)\n\n$x\n\n\n$y\n\nbody(f02)\n\n{\n    x + y\n}\n\nenvironment(f02)\n\n&lt;environment: R_GlobalEnv&gt;\n\n\n\n\n\n\n\n\n\n2.3.1 Calling\n\nRPython\n\n\nCalling Syntax:\n\nfunction_name(argument1 = value1, argument2 = value2, ...)\n\nTry using seq(), which makes regular sequences of numbers:\n\nseq(from = 1, to = 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWe often omit the names of the first several arguments in function calls, so we can rewrite this as follows:\n\nseq(1, 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWe can also check the arguments and other information with:\n?seq\nThe “help” windows shows as:\n\n\n\n\nsequence = list(range(1, 11))\nprint(sequence)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n\n\n\n\n\n\n2.3.2 Creating\n\nRPython\n\n\nUse the function() keyword:\n\nmy_add1 &lt;- function(x) {\n  x + 1\n}\n\ncalling the function my_add1:\n\nmy_add1(2)\n\n[1] 3\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn R, the return statement is not essential for a function to yield a value as its result. By default, R will return the result of the last command within the function as its output.\n\n\n\n\nIn Python a function is defined using the def keyword:\n\ndef my_add(x):\n  return x + 1\n\ncalling the function my_add1:\n\nprint(my_add(2))\n\n3\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThe return statement is essential for a function to yield a value as its result."
  },
  {
    "objectID": "dataprocess/basic_r_python.html#naming-conventions",
    "href": "dataprocess/basic_r_python.html#naming-conventions",
    "title": "R & Python Basic",
    "section": "3.2 Naming Conventions",
    "text": "3.2 Naming Conventions\n\nCamel Case\n\nEach word, except the first, starts with a capital letter:\nmyVariableName\n\nPascal Case\n\nEach word starts with a capital letter:\nMyVariableName\n\nSnake Case\n\nEach word is separated by an underscore character:\nmy_variable_name"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#data-manipulate",
    "href": "dataprocess/basic_r_python.html#data-manipulate",
    "title": "R & Python Basic",
    "section": "1.3 Data Manipulate",
    "text": "1.3 Data Manipulate\nData manipulation is the art and science of transforming raw data into a more structured and useful format for analysis, interpretation, and decision-making. It’s a fundamental process in data science, analytics, and database management.\nOperations for creating and managing persistent data elements can be summarized as CRUD:\n\nCreate (Add): The creation of new data elements or records.\nRead: The retrieval and access of existing data elements for analysis or presentation.\nUpdate: The modification or editing of data elements to reflect changes or corrections.\nDelete: The removal or elimination of data elements that are no longer needed or relevant.\n\nAdditionally, subsetting plays a crucial role in data manipulation. Subsetting allows you to extract specific subsets of data based on conditions, criteria, or filters.\nCombining CRUD operations with subsetting provides a powerful toolkit for working with data, ensuring its accuracy, relevance, and utility in various applications, from database management to data analysis.\n\n1.3.1 Subsetting\n\nRPython\n\n\nMore Details in Advanced R: 4 Subsetting.\nR’s subsetting operators are fast and powerful. Mastering them allows you to succinctly perform complex operations in a way that few other languages can match. Subsetting in R is easy to learn but hard to master because you need to internalise a number of interrelated concepts:\n\nThere are six ways to subset atomic vectors.\nThere are three subsetting operators, [[, [, and $.\nSubsetting operators interact differently with different vector types (e.g., atomic vectors, lists, factors, matrices, and data frames).\n\nSubsetting is a natural complement to str(). While str() shows you all the pieces of any object (its structure).\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn Python, indexing starts from 0, not 1.\n\n\n\n\n\n\n1.3.1.1 Vector\n\nRPython\n\n\n\nPositive integers return elements at the specified positions:\n\n\nx &lt;- c(2.1, 4.2, 3.3, 5.4)\n\n# One value\nx[1]\n\n[1] 2.1\n\n# More values\nx[c(1:2, 4)]\n\n[1] 2.1 4.2 5.4\n\n# Duplicate indices will duplicate values\nx[c(1, 1)]\n\n[1] 2.1 2.1\n\n# Real numbers are silently truncated to integers\nx[c(2.1, 2.9)]\n\n[1] 4.2 4.2\n\n\n\nNegative integers exclude elements at the specified positions:\n\n\n# Exclude elements\nx[-c(3, 1)]\n\n[1] 4.2 5.4\n\n\n\n\n\n\n\n\nError\n\n\n\nNote that you can’t mix positive and negative integers in a single subset:\n\n\n\nx[c(-1, 2)]\n\nError in x[c(-1, 2)]: nur Nullen dürfen mit negativen Indizes gemischt werden\n\n\n\n\n\nPositive integers return elements at the specified positions:\n\n\nimport numpy as np\nimport pandas as pd\n\n# Create a NumPy array\nx = np.array([2.1, 4.2, 3.3, 5.4])\n\n# One value\nprint(x[0])\n\n2.1\n\n# More values\nprint(x[np.array([0, 1, 3])])\n\n[2.1 4.2 5.4]\n\n# Duplicate indices will duplicate values\nprint(x[np.array([0, 0])])\n\n[2.1 2.1]\n\n\n\negative indexing to access an array from the end:\n\n\n# One value\nprint(x[-1])\n\n5.4\n\n# More values\nprint(x[-np.array([1, 3])])\n\n[5.4 4.2]\n\n\n\n\n\n\n\n1.3.1.2 Matrices and arrays\n\nRPython\n\n\nThe most common way of subsetting matrices (2D) and arrays (&gt;2D) is a simple generalisation of 1D subsetting: supply a 1D index for each dimension, separated by a comma. Blank subsetting is now useful because it lets you keep all rows or all columns.\n\n# Create a NumPy matrix\na2 &lt;- matrix(1:9, nrow = 3)\n# Rename the columns (equivalent to colnames in R)\ncolnames(a2) &lt;- c(\"A\", \"B\", \"C\")\n# Access a specific element using column name\na2[1, \"A\"]\n\nA \n1 \n\n# Select specific rows with all columns\na2[1:2, ]\n\n     A B C\n[1,] 1 4 7\n[2,] 2 5 8\n\n# columns which are excluded \na2[0, -2]\n\n     A C\n\n# Create a 3D array\na3 &lt;- array(1:24, c(2,3,4))\n# Access a specific element(s), in different dimensions\na3[1,2,2]\n\n[1] 9\n\na3[1,2,]\n\n[1]  3  9 15 21\n\na3[1,,]\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    7   13   19\n[2,]    3    9   15   21\n[3,]    5   11   17   23\n\n\n\n\nIn Python, the : symbol is used to indicate all elements of a particular dimension or slice. It allows you to select or reference all items along that dimension in a sequence, array, or data structure.\n\nimport numpy as np\n\n# Create a NumPy matrix\na2 = np.array([[1, 2, 3],\n               [4, 5, 6],\n               [7, 8, 9]])\n\n# Rename the columns (equivalent to colnames in R)\ncolnames = [\"A\", \"B\", \"C\"]\n\n# Access a specific element using column name\nprint(a2[0, colnames.index(\"A\")])\n\n1\n\n# Select the first two rows\nprint(a2[0:2, :])\n\n[[1 2 3]\n [4 5 6]]\n\n# Create a NumPy 3D array\na3 = np.arange(1, 25).reshape((2, 3, 4))\n\n# Access a specific element in the 3D array\nprint(a3[0, 1, 1])\n\n6\n\nprint(a3[0, 1, :])\n\n[5 6 7 8]\n\nprint(a3[0, :, :])\n\n[[ 1  2  3  4]\n [ 5  6  7  8]\n [ 9 10 11 12]]\n\n\n\n\n\n\n\n1.3.1.3 Data frames and tibbles\n\nRPython\n\n\nData frames have the characteristics of both lists and matrices:\n\nWhen subsetting with a single index, they behave like lists and index the columns, so df[1:2] selects the first two columns.\nWhen subsetting with two indices, they behave like matrices, so df[1:3, ] selects the first three rows (and all the columns)[^python-dims].\n\n\n# Create a DataFrame\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\n\n# Select rows\ndf[df$x == 2, ]\n\n  x y z\n2 2 2 b\n\ndf[c(1, 3), ]\n\n  x y z\n1 1 3 a\n3 3 1 c\n\n# There are two ways to select columns from a data frame\n# Like a list\ndf[c(\"x\", \"z\")]\n\n  x z\n1 1 a\n2 2 b\n3 3 c\n\n# Like a matrix\ndf[, c(\"x\", \"z\")]\n\n  x z\n1 1 a\n2 2 b\n3 3 c\n\n# There's an important difference if you select a single \n# column: matrix subsetting simplifies by default, list \n# subsetting does not.\nstr(df[\"x\"])\n\n'data.frame':   3 obs. of  1 variable:\n $ x: int  1 2 3\n\nstr(df[, \"x\"])\n\n int [1:3] 1 2 3\n\n\n\n\nMore detail about Function pandas.Seies.iloc() and pandas.Seies.loc() in pandas document\n\nloc gets rows (and/or columns) with particular labels.\niloc gets rows (and/or columns) at integer locations.\n\n\nimport pandas as pd\n\n# Create a DataFrame\ndf = pd.DataFrame({'x': range(1, 4), 'y': range(3, 0, -1), 'z': list('abc')})\n\n# Select rows\nprint(df[df['x'] == 2])\n\n   x  y  z\n1  2  2  b\n\nprint(df.iloc[[0, 2]])\n\n   x  y  z\n0  1  3  a\n2  3  1  c\n\n# Select columns\nprint(df[['x', 'z']])\n\n   x  z\n0  1  a\n1  2  b\n2  3  c\n\n# Select columns like a DataFrame\nprint(df.loc[:, ['x', 'z']])\n\n   x  z\n0  1  a\n1  2  b\n2  3  c\n\n# Select a single column as a Series (simplifies by default)\nprint(df['x'])\n\n0    1\n1    2\n2    3\nName: x, dtype: int64\n\n# Select a single column as a DataFrame (does not simplify)\nprint(df[['x']])\n\n   x\n0  1\n1  2\n2  3\n\n\n\n\n\n\n\n1.3.1.4 List\n\nRPython"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#math",
    "href": "dataprocess/basic_r_python.html#math",
    "title": "R & Python Basic",
    "section": "2.1 Math",
    "text": "2.1 Math\n\n‘+’ ‘-’ ’*’ ‘/’\nExponent, Logarithm\nTrigonometric functions\nLinear algebra, Matrix multiplication\n\n\nRPython\n\n\n\n1 / 200 * 30\n\n[1] 0.15\n\n(59 + 73 - 2) / 3\n\n[1] 43.33333\n\n3^2\n\n[1] 9\n\nsin(pi / 2) # pi as Const number in R\n\n[1] 1\n\n\n\n\n\nprint(1 / 200 * 30)\n\n0.15\n\nprint((59 + 73 - 2) / 3)\n\n43.333333333333336\n\nprint(3**2)\n\n9\n\nimport math\nprint(math.sin(math.pi/2))\n\n1.0"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#subsetting-und-idexing",
    "href": "dataprocess/basic_r_python.html#subsetting-und-idexing",
    "title": "R & Python Basic",
    "section": "1.3 Subsetting und idexing",
    "text": "1.3 Subsetting und idexing\nAdditionally, subsetting plays a crucial role in data manipulation. Subsetting allows you to extract specific subsets of data based on conditions, criteria, or filters.\n\nRPython\n\n\nMore Details in Advanced R: 4 Subsetting.\nR’s subsetting operators are fast and powerful. Mastering them allows you to succinctly perform complex operations in a way that few other languages can match. Subsetting in R is easy to learn but hard to master because you need to internalise a number of interrelated concepts:\n\nThere are six ways to subset atomic vectors.\nThere are three subsetting operators, [[, [, and $.\nSubsetting operators interact differently with different vector types (e.g., atomic vectors, lists, factors, matrices, and data frames).\n\nSubsetting is a natural complement to str(). While str() shows you all the pieces of any object (its structure).\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn Python, indexing starts from 0, not 1.\n\n\n\n\n\n\n1.3.1 Vector\n\nRPython\n\n\n\nPositive integers return elements at the specified positions:\n\n\nx &lt;- c(2.1, 4.2, 3.3, 5.4)\n\n# One value\nx[1]\n\n[1] 2.1\n\n# More values\nx[c(1:2, 4)]\n\n[1] 2.1 4.2 5.4\n\n# Duplicate indices will duplicate values\nx[c(1, 1)]\n\n[1] 2.1 2.1\n\n# Real numbers are silently truncated to integers\nx[c(2.1, 2.9)]\n\n[1] 4.2 4.2\n\n\n\nNegative integers exclude elements at the specified positions:\n\n\n# Exclude elements\nx[-c(3, 1)]\n\n[1] 4.2 5.4\n\n\n\n\n\n\n\n\nError\n\n\n\nNote that you can’t mix positive and negative integers in a single subset:\n\n\n\nx[c(-1, 2)]\n\nError in x[c(-1, 2)]: nur Nullen dürfen mit negativen Indizes gemischt werden\n\n\n\n\n\nPositive integers return elements at the specified positions:\n\n\nimport numpy as np\nimport pandas as pd\n\n# Create a NumPy array\nx = np.array([2.1, 4.2, 3.3, 5.4])\n\n# One value\nprint(x[0])\n\n2.1\n\n# More values\nprint(x[np.array([0, 1, 3])])\n\n[2.1 4.2 5.4]\n\n# Duplicate indices will duplicate values\nprint(x[np.array([0, 0])])\n\n[2.1 2.1]\n\n\n\negative indexing to access an array from the end:\n\n\n# One value\nprint(x[-1])\n\n5.4\n\n# More values\nprint(x[-np.array([1, 3])])\n\n[5.4 4.2]\n\n\n\n\n\n\n\n1.3.2 Matrices and arrays\n\nRPython\n\n\nThe most common way of subsetting matrices (2D) and arrays (&gt;2D) is a simple generalisation of 1D subsetting: supply a 1D index for each dimension, separated by a comma. Blank subsetting is now useful because it lets you keep all rows or all columns.\n\n# Create a NumPy matrix\na2 &lt;- matrix(1:9, nrow = 3)\n# Rename the columns (equivalent to colnames in R)\ncolnames(a2) &lt;- c(\"A\", \"B\", \"C\")\n# Access a specific element using column name\na2[1, \"A\"]\n\nA \n1 \n\n# Select specific rows with all columns\na2[1:2, ]\n\n     A B C\n[1,] 1 4 7\n[2,] 2 5 8\n\n# columns which are excluded \na2[0, -2]\n\n     A C\n\n# Create a 3D array\na3 &lt;- array(1:24, c(2,3,4))\n# Access a specific element(s), in different dimensions\na3[1,2,2]\n\n[1] 9\n\na3[1,2,]\n\n[1]  3  9 15 21\n\na3[1,,]\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    7   13   19\n[2,]    3    9   15   21\n[3,]    5   11   17   23\n\n\n\n\nIn Python, the : symbol is used to indicate all elements of a particular dimension or slice. It allows you to select or reference all items along that dimension in a sequence, array, or data structure.\n\nimport numpy as np\n\n# Create a NumPy matrix\na2 = np.array([[1, 2, 3],\n               [4, 5, 6],\n               [7, 8, 9]])\n\n# Rename the columns (equivalent to colnames in R)\ncolnames = [\"A\", \"B\", \"C\"]\n\n# Access a specific element using column name\nprint(a2[0, colnames.index(\"A\")])\n\n1\n\n# Select the first two rows\nprint(a2[0:2, :])\n\n[[1 2 3]\n [4 5 6]]\n\n# Create a NumPy 3D array\na3 = np.arange(1, 25).reshape((2, 3, 4))\n\n# Access a specific element in the 3D array\nprint(a3[0, 1, 1])\n\n6\n\nprint(a3[0, 1, :])\n\n[5 6 7 8]\n\nprint(a3[0, :, :])\n\n[[ 1  2  3  4]\n [ 5  6  7  8]\n [ 9 10 11 12]]\n\n\n\n\n\n\n\n1.3.3 Data frames and tibbles\n\nRPython\n\n\nData frames have the characteristics of both lists and matrices:\n\nWhen subsetting with a single index, they behave like lists and index the columns, so df[1:2] selects the first two columns.\nWhen subsetting with two indices, they behave like matrices, so df[1:3, ] selects the first three rows (and all the columns)[^python-dims].\n\n\n# Create a DataFrame\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\n\n# Select rows\ndf[df$x == 2, ]\n\n  x y z\n2 2 2 b\n\ndf[c(1, 3), ]\n\n  x y z\n1 1 3 a\n3 3 1 c\n\n# There are two ways to select columns from a data frame\n# Like a list\ndf[c(\"x\", \"z\")]\n\n  x z\n1 1 a\n2 2 b\n3 3 c\n\n# Like a matrix\ndf[, c(\"x\", \"z\")]\n\n  x z\n1 1 a\n2 2 b\n3 3 c\n\n# There's an important difference if you select a single \n# column: matrix subsetting simplifies by default, list \n# subsetting does not.\nstr(df[\"x\"])\n\n'data.frame':   3 obs. of  1 variable:\n $ x: int  1 2 3\n\nstr(df[, \"x\"])\n\n int [1:3] 1 2 3\n\n\n\n\nMore detail about Function pandas.Seies.iloc() and pandas.Seies.loc() in pandas document\n\nloc gets rows (and/or columns) with particular labels.\niloc gets rows (and/or columns) at integer locations.\n\n\nimport pandas as pd\n\n# Create a DataFrame\ndf = pd.DataFrame({'x': range(1, 4), 'y': range(3, 0, -1), 'z': list('abc')})\n\n# Select rows\nprint(df[df['x'] == 2])\n\n   x  y  z\n1  2  2  b\n\nprint(df.iloc[[0, 2]])\n\n   x  y  z\n0  1  3  a\n2  3  1  c\n\n# Select columns\nprint(df[['x', 'z']])\n\n   x  z\n0  1  a\n1  2  b\n2  3  c\n\n# Select columns like a DataFrame\nprint(df.loc[:, ['x', 'z']])\n\n   x  z\n0  1  a\n1  2  b\n2  3  c\n\n# Select a single column as a Series (simplifies by default)\nprint(df['x'])\n\n0    1\n1    2\n2    3\nName: x, dtype: int64\n\n# Select a single column as a DataFrame (does not simplify)\nprint(df[['x']])\n\n   x\n0  1\n1  2\n2  3\n\n\n\n\n\n\n\n1.3.4 List\n\nRPython\n\n\nThere are two other subsetting operators: [[ and $. [[ is used for extracting single items, while x$y is a useful shorthand for x[[\"y\"]].\n[[ is most important when working with lists because subsetting a list with [ always returns a smaller list. To help make this easier to understand we can use a metaphor:\n[[ can return only a single item, you must use it with either a single positive integer or a single string.\n\nx &lt;- list(a = 1:3, b = \"a\", d = 4:6)\n\n# Get the subset \nx[1]\n\n$a\n[1] 1 2 3\n\nstr(x[1])\n\nList of 1\n $ a: int [1:3] 1 2 3\n\nx[1:2]\n\n$a\n[1] 1 2 3\n\n$b\n[1] \"a\"\n\n# Get the element\nx[[1]]\n\n[1] 1 2 3\n\nstr(x[1])\n\nList of 1\n $ a: int [1:3] 1 2 3\n\n# with Label\nx$a\n\n[1] 1 2 3\n\nx[[\"a\"]]\n\n[1] 1 2 3\n\n\n\n\nIn Python there are no effectiv ways to create a items named list. It can always get the element of the list but not a subset of the list.\nIn Python, there are no effective ways to create items with named elements in a list. While you can access individual elements by their positions, there isn’t a straightforward method to create a subset of the list with named elements.\n\n# Create a Python list with nested lists\nx = [list(range(1, 4)), \"a\", list(range(4, 7))]\n\n# Get the subset (Python list slice)\nprint([x[0]])\n\n[[1, 2, 3]]\n\n# Get the element using list indexing\nprint(x[0])\n\n[1, 2, 3]\n\nprint(type(x[0]))\n\n&lt;class 'list'&gt;\n\n\nHowever, dictionaries in Python excel in this regard, as they allow you to assign and access elements using user-defined keys, providing a more efficient way to work with named elements and subsets of data.\n\n# Create a dictionary with labels\nx = {\"a\": list(range(1, 4)), \"b\": \"a\", \"d\": list(range(4, 7))}\n\n\n# Get the element using dictionary indexing\nprint(x[\"a\"])\n\n[1, 2, 3]\n\n# Access an element with a label\nprint(x[\"a\"])\n\n[1, 2, 3]\n\nprint(x.get(\"a\"))\n\n[1, 2, 3]\n\nprint(type(x[\"a\"]))\n\n&lt;class 'list'&gt;"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#data-crud",
    "href": "dataprocess/basic_r_python.html#data-crud",
    "title": "R & Python Basic",
    "section": "1.4 Data CRUD",
    "text": "1.4 Data CRUD\nData manipulation is the art and science of transforming raw data into a more structured and useful format for analysis, interpretation, and decision-making. It’s a fundamental process in data science, analytics, and database management.\nOperations for creating and managing persistent data elements can be summarized as CRUD:\n\nCreate (Add): The creation of new data elements or records.\nRead: The retrieval and access of existing data elements for analysis or presentation.\nUpdate: The modification or editing of data elements to reflect changes or corrections.\nDelete: The removal or elimination of data elements that are no longer needed or relevant.\n\nCombining CRUD operations with subsetting provides a powerful toolkit for working with data, ensuring its accuracy, relevance, and utility in various applications, from database management to data analysis.\n\n1.4.1 Add\n\n\n1.4.2 Read\nThe read process is essentially a form of subsetting, where you access specific elements or subsets of data using their indexes. The crucial aspect of this operation is how to obtain and utilize these indexes effectively.\n\nRPython\n\n\n\n# Create a DataFrame\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\n\n# Access using integer index \ndf[1,2]\n\n[1] 3\n\n# Access using names index\ndf[,\"z\"]\n\n[1] \"a\" \"b\" \"c\"\n\ndf$z\n\n[1] \"a\" \"b\" \"c\"\n\n# Access with a value condition\nidx &lt;- which(df$x &gt; 1)\ndf[idx,]\n\n  x y z\n2 2 2 b\n3 3 1 c\n\ndf[idx, \"z\"]\n\n[1] \"b\" \"c\"\n\nidx &lt;- which(df$z == \"a\")\ndf[idx,]\n\n  x y z\n1 1 3 a\n\ndf[idx, 1:2]\n\n  x y\n1 1 3\n\n\n\n\n\nimport pandas as pd\n\n# Create a pandas DataFrame\ndf = pd.DataFrame({'x': range(1, 4), 'y': range(3, 0, -1), 'z': list('abc')})\n\n# Access using integer index (iloc)\nprint(df.iloc[0, 1])\n\n3\n\n# Access using column label\nprint(df['z'])\n\n0    a\n1    b\n2    c\nName: z, dtype: object\n\nprint(df.z)\n\n0    a\n1    b\n2    c\nName: z, dtype: object\n\n# Access with a value condition\nidx = df['x'] &gt; 1\nprint(df[idx])\n\n   x  y  z\n1  2  2  b\n2  3  1  c\n\nprint(df[df['z'] == 'a'])\n\n   x  y  z\n0  1  3  a\n\nprint(df[df['z'] == 'a'][['x', 'y']])\n\n   x  y\n0  1  3\n\n\n\n\n\n\n\n1.4.3 Update\nThe update operation builds upon the principles of reading. It involves replacing an existing value with a new one, but with certain constraints. The new value must have the same data type, size, and structure as the original value. This ensures data consistency and integrity when modifying data elements. About “data type” it is not so strength, somtimes it is chanable if you replace the whol e.g. colums in data frame.\nIt’s important to note that the concept of ‘data type’ isn’t always rigid. There are cases where data types can change, particularly when replacing entire columns in a data frame, for instance. While data types typically define the expected format and behavior of data, specific operations and transformations may lead to changes in data types to accommodate new values or structures.\n\nRPython\n\n\n\n# Create a DataFrame\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf\n\n  x y z\n1 1 3 a\n2 2 2 b\n3 3 1 c\n\n# Update using integer index \ndf[1,2] &lt;- 0\ndf\n\n  x y z\n1 1 0 a\n2 2 2 b\n3 3 1 c\n\n# Update using names index\ndf[2,\"z\"] &lt;- \"lk\"\ndf\n\n  x y  z\n1 1 0  a\n2 2 2 lk\n3 3 1  c\n\n# Update with a value condition\nidx &lt;- which(df$x &gt; 1)\ndf[idx, \"z\"] &lt;- \"bg1\"\ndf\n\n  x y   z\n1 1 0   a\n2 2 2 bg1\n3 3 1 bg1\n\nidx &lt;- which(df$z == \"a\")\ndf[idx,] &lt;- c(-1, -5, \"new_a\")\ndf\n\n   x  y     z\n1 -1 -5 new_a\n2  2  2   bg1\n3  3  1   bg1\n\n\n\n\n\nimport pandas as pd\n\n# Create a pandas DataFrame\ndf = pd.DataFrame({'x': range(1, 4), 'y': range(3, 0, -1), 'z': list('abc')})\nprint(df)\n\n   x  y  z\n0  1  3  a\n1  2  2  b\n2  3  1  c\n\n# Update using integer index\ndf.iat[0, 1] = 0\nprint(df)\n\n   x  y  z\n0  1  0  a\n1  2  2  b\n2  3  1  c\n\n# Update using column label and row index\ndf.at[1, 'z'] = \"lk\"\nprint(df)\n\n   x  y   z\n0  1  0   a\n1  2  2  lk\n2  3  1   c\n\n# Update with a value condition\nidx_x_gt_1 = df['x'] &gt; 1\ndf.loc[idx_x_gt_1, 'z'] = \"bg1\"\nprint(df)\n\n   x  y    z\n0  1  0    a\n1  2  2  bg1\n2  3  1  bg1\n\nidx_z_eq_a = df['z'] == 'a'\ndf.loc[idx_z_eq_a] = [-1, -5, \"new_a\"]\nprint(df)\n\n   x  y      z\n0 -1 -5  new_a\n1  2  2    bg1\n2  3  1    bg1\n\n\n\n\n\n\n\n1.4.4 Delete\n\nRPython\n\n\nDeletion in R can be accomplished relatively easily using methods like specifying negative integer indices or setting elements to NULL within a list. However, it’s essential to recognize that there are limitations to deletion operations. For instance, when dealing with multi-dimensional arrays, you cannot delete a single element in the same straightforward manner; instead, you can only delete entire sub-dimensions.\n\n# Create a DataFrame\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\ndf\n\n  x y z\n1 1 3 a\n2 2 2 b\n3 3 1 c\n\n# Delete using negative integer index \ndf[,-2]\n\n  x z\n1 1 a\n2 2 b\n3 3 c\n\ndf[-2,]\n\n  x y z\n1 1 3 a\n3 3 1 c\n\n# Setting elements to `NULL`\ndf$y &lt;- NULL\ndf\n\n  x z\n1 1 a\n2 2 b\n3 3 c\n\n\n\n\nIn Python is to use the .drop() command to delete the elemnts in datatframe. More details in pandas document\n\ndf = pd.DataFrame({'x': range(1, 4), 'y': range(3, 0, -1), 'z': list('abc')})\nprint(df)\n\n   x  y  z\n0  1  3  a\n1  2  2  b\n2  3  1  c\n\n# Drop columns\nprint(df.drop(['x', 'z'], axis=1))\n\n   y\n0  3\n1  2\n2  1\n\nprint(df.drop(columns=['x', 'y']))\n\n   z\n0  a\n1  b\n2  c\n\n# Drop a row by index\nprint(df.drop([0, 1]))\n\n   x  y  z\n2  3  1  c"
  },
  {
    "objectID": "dataprocess/basic_r_python.html#index-subset",
    "href": "dataprocess/basic_r_python.html#index-subset",
    "title": "R & Python Basic",
    "section": "1.3 Index & subset",
    "text": "1.3 Index & subset\nAdditionally, subsetting plays a crucial role in data manipulation. Subsetting allows you to extract specific subsets of data based on conditions, criteria, or filters.\n\nRPython\n\n\nMore Details in Advanced R: 4 Subsetting.\nR’s subsetting operators are fast and powerful. Mastering them allows you to succinctly perform complex operations in a way that few other languages can match. Subsetting in R is easy to learn but hard to master because you need to internalise a number of interrelated concepts:\n\nThere are six ways to subset atomic vectors.\nThere are three subsetting operators, [[, [, and $.\nSubsetting operators interact differently with different vector types (e.g., atomic vectors, lists, factors, matrices, and data frames).\n\nSubsetting is a natural complement to str(). While str() shows you all the pieces of any object (its structure).\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn Python, indexing starts from 0, not 1.\n\n\n\n\n\n\n1.3.1 Vector\n\nRPython\n\n\n\nPositive integers return elements at the specified positions:\n\n\nx &lt;- c(2.1, 4.2, 3.3, 5.4)\n\n# One value\nx[1]\n\n[1] 2.1\n\n# More values\nx[c(1:2, 4)]\n\n[1] 2.1 4.2 5.4\n\n# Duplicate indices will duplicate values\nx[c(1, 1)]\n\n[1] 2.1 2.1\n\n# Real numbers are silently truncated to integers\nx[c(2.1, 2.9)]\n\n[1] 4.2 4.2\n\n\n\nNegative integers exclude elements at the specified positions:\n\n\n# Exclude elements\nx[-c(3, 1)]\n\n[1] 4.2 5.4\n\n\n\n\n\n\n\n\nError\n\n\n\nNote that you can’t mix positive and negative integers in a single subset:\n\n\n\nx[c(-1, 2)]\n\nError in x[c(-1, 2)]: nur Nullen dürfen mit negativen Indizes gemischt werden\n\n\n\n\n\nPositive integers return elements at the specified positions:\n\n\nimport numpy as np\nimport pandas as pd\n\n# Create a NumPy array\nx = np.array([2.1, 4.2, 3.3, 5.4])\n\n# One value\nprint(x[0])\n\n2.1\n\n# More values\nprint(x[np.array([0, 1, 3])])\n\n[2.1 4.2 5.4]\n\n# Duplicate indices will duplicate values\nprint(x[np.array([0, 0])])\n\n[2.1 2.1]\n\n\n\negative indexing to access an array from the end:\n\n\n# One value\nprint(x[-1])\n\n5.4\n\n# More values\nprint(x[-np.array([1, 3])])\n\n[5.4 4.2]\n\n\n\n\n\n\n\n1.3.2 Matrices and arrays\n\nRPython\n\n\nThe most common way of subsetting matrices (2D) and arrays (&gt;2D) is a simple generalisation of 1D subsetting: supply a 1D index for each dimension, separated by a comma. Blank subsetting is now useful because it lets you keep all rows or all columns.\n\n# Create a NumPy matrix\na2 &lt;- matrix(1:9, nrow = 3)\n# Rename the columns (equivalent to colnames in R)\ncolnames(a2) &lt;- c(\"A\", \"B\", \"C\")\n# Access a specific element using column name\na2[1, \"A\"]\n\nA \n1 \n\n# Select specific rows with all columns\na2[1:2, ]\n\n     A B C\n[1,] 1 4 7\n[2,] 2 5 8\n\n# columns which are excluded \na2[0, -2]\n\n     A C\n\n# Create a 3D array\na3 &lt;- array(1:24, c(2,3,4))\n# Access a specific element(s), in different dimensions\na3[1,2,2]\n\n[1] 9\n\na3[1,2,]\n\n[1]  3  9 15 21\n\na3[1,,]\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    7   13   19\n[2,]    3    9   15   21\n[3,]    5   11   17   23\n\n\n\n\nIn Python, the : symbol is used to indicate all elements of a particular dimension or slice. It allows you to select or reference all items along that dimension in a sequence, array, or data structure.\n\nimport numpy as np\n\n# Create a NumPy matrix\na2 = np.array([[1, 2, 3],\n               [4, 5, 6],\n               [7, 8, 9]])\n\n# Rename the columns (equivalent to colnames in R)\ncolnames = [\"A\", \"B\", \"C\"]\n\n# Access a specific element using column name\nprint(a2[0, colnames.index(\"A\")])\n\n1\n\n# Select the first two rows\nprint(a2[0:2, :])\n\n[[1 2 3]\n [4 5 6]]\n\n# Create a NumPy 3D array\na3 = np.arange(1, 25).reshape((2, 3, 4))\n\n# Access a specific element in the 3D array\nprint(a3[0, 1, 1])\n\n6\n\nprint(a3[0, 1, :])\n\n[5 6 7 8]\n\nprint(a3[0, :, :])\n\n[[ 1  2  3  4]\n [ 5  6  7  8]\n [ 9 10 11 12]]\n\n\n\n\n\n\n\n1.3.3 Data frames\n\nRPython\n\n\nData frames have the characteristics of both lists and matrices:\n\nWhen subsetting with a single index, they behave like lists and index the columns, so df[1:2] selects the first two columns.\nWhen subsetting with two indices, they behave like matrices, so df[1:3, ] selects the first three rows (and all the columns)[^python-dims].\n\n\n# Create a DataFrame\ndf &lt;- data.frame(x = 1:3, y = 3:1, z = letters[1:3])\n\n# Select rows\ndf[df$x == 2, ]\n\n  x y z\n2 2 2 b\n\ndf[c(1, 3), ]\n\n  x y z\n1 1 3 a\n3 3 1 c\n\n# There are two ways to select columns from a data frame\n# Like a list\ndf[c(\"x\", \"z\")]\n\n  x z\n1 1 a\n2 2 b\n3 3 c\n\n# Like a matrix\ndf[, c(\"x\", \"z\")]\n\n  x z\n1 1 a\n2 2 b\n3 3 c\n\n# There's an important difference if you select a single \n# column: matrix subsetting simplifies by default, list \n# subsetting does not.\nstr(df[\"x\"])\n\n'data.frame':   3 obs. of  1 variable:\n $ x: int  1 2 3\n\nstr(df[, \"x\"])\n\n int [1:3] 1 2 3\n\n\n\n\nMore detail about Function pandas.Seies.iloc() and pandas.Seies.loc() in pandas document\n\nloc gets rows (and/or columns) with particular labels.\niloc gets rows (and/or columns) at integer locations.\n\n\nimport pandas as pd\n\n# Create a DataFrame\ndf = pd.DataFrame({'x': range(1, 4), 'y': range(3, 0, -1), 'z': list('abc')})\n\n# Select rows\nprint(df[df['x'] == 2])\n\n   x  y  z\n1  2  2  b\n\nprint(df.iloc[[0, 2]])\n\n   x  y  z\n0  1  3  a\n2  3  1  c\n\n# Select columns\nprint(df[['x', 'z']])\n\n   x  z\n0  1  a\n1  2  b\n2  3  c\n\n# Select columns like a DataFrame\nprint(df.loc[:, ['x', 'z']])\n\n   x  z\n0  1  a\n1  2  b\n2  3  c\n\n# Select a single column as a Series (simplifies by default)\nprint(df['x'])\n\n0    1\n1    2\n2    3\nName: x, dtype: int64\n\n# Select a single column as a DataFrame (does not simplify)\nprint(df[['x']])\n\n   x\n0  1\n1  2\n2  3\n\n\n\n\n\n\n\n1.3.4 List\n\nRPython\n\n\nThere are two other subsetting operators: [[ and $. [[ is used for extracting single items, while x$y is a useful shorthand for x[[\"y\"]].\n[[ is most important when working with lists because subsetting a list with [ always returns a smaller list. To help make this easier to understand we can use a metaphor:\n[[ can return only a single item, you must use it with either a single positive integer or a single string.\n\nx &lt;- list(a = 1:3, b = \"a\", d = 4:6)\n\n# Get the subset \nx[1]\n\n$a\n[1] 1 2 3\n\nstr(x[1])\n\nList of 1\n $ a: int [1:3] 1 2 3\n\nx[1:2]\n\n$a\n[1] 1 2 3\n\n$b\n[1] \"a\"\n\n# Get the element\nx[[1]]\n\n[1] 1 2 3\n\nstr(x[1])\n\nList of 1\n $ a: int [1:3] 1 2 3\n\n# with Label\nx$a\n\n[1] 1 2 3\n\nx[[\"a\"]]\n\n[1] 1 2 3\n\n\n\n\nIn Python there are no effectiv ways to create a items named list. It can always get the element of the list but not a subset of the list.\nIn Python, there are no effective ways to create items with named elements in a list. While you can access individual elements by their positions, there isn’t a straightforward method to create a subset of the list with named elements.\n\n# Create a Python list with nested lists\nx = [list(range(1, 4)), \"a\", list(range(4, 7))]\n\n# Get the subset (Python list slice)\nprint([x[0]])\n\n[[1, 2, 3]]\n\n# Get the element using list indexing\nprint(x[0])\n\n[1, 2, 3]\n\nprint(type(x[0]))\n\n&lt;class 'list'&gt;\n\n\nHowever, dictionaries in Python excel in this regard, as they allow you to assign and access elements using user-defined keys, providing a more efficient way to work with named elements and subsets of data.\n\n# Create a dictionary with labels\nx = {\"a\": list(range(1, 4)), \"b\": \"a\", \"d\": list(range(4, 7))}\n\n\n# Get the element using dictionary indexing\nprint(x[\"a\"])\n\n[1, 2, 3]\n\n# Access an element with a label\nprint(x[\"a\"])\n\n[1, 2, 3]\n\nprint(x.get(\"a\"))\n\n[1, 2, 3]\n\nprint(type(x[\"a\"]))\n\n&lt;class 'list'&gt;"
  }
]