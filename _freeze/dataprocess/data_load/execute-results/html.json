{
  "hash": "0eaf533062a76c1cb19b340c214cd687",
  "result": {
    "markdown": "---\ntitle: \"load data\"\nexecute:\n  warning: false\n  error: false\nsidebar:\n  contents: auto\n---\n\n\nThis Aritcl will show the process to load data from other files. I t will divide into four paties: plain text (read able ASCII), Excel, NetCDF and spatial data. \n\n# Plain text File\n\nFor more details about date (file) format, you can refer to the article titled [Basic Data & File Format](basic_format.qmd).\n\n## Example File\n\nLet's start with an example CSV file named `Bachum_2763190000100.csv`. This file contains pegel discharge data and is sourced from open data available at [ELWAS-WEB NRW](https://www.elwasweb.nrw.de/elwas-web/index.xhtml). You can also access it directly from the internet via [Github](https://raw.githubusercontent.com/HydroSimul/Web/main/data_share/Bachum_2763190000100.csv), just like you would access a local file.\n\nTake a look:\n\n\n![](../images/bachum.png)\n\n## R library and functions\n\nFirst, we need to load the necessary library `tidyverse`. This library collection includes `readr` for reading files and `dplyr` for data manipulation, among others.\n\nAnd, we set the URL address as the file path (including the file name).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nfn_Bachum <- \"https://raw.githubusercontent.com/HydroSimul/Web/main/data_share/Bachum_2763190000100.csv\"\n```\n:::\n\n\nThe documentation for the `readr` library is available online and can be accessed at [https://readr.tidyverse.org](https://readr.tidyverse.org). \n\nOf particular interest are the following functions:\n\n- [readr::read_csv()](https://readr.tidyverse.org/reference/read_delim.html)\n- [readr::read_table()](https://readr.tidyverse.org/reference/read_table.html)\n\nWe can observe that the CSV file is divided by semicolons. Therefore, it's more appropriate to use `read_csv2()` rather than `read_csv()`.\n\n## Metadata Handel\n\nMetadata can vary widely between datasets, so it's handled separately from the data body.\n\nThere are three ways to deal with metadata:\n\n1. **Directly Ignore:** This approach involves ignoring metadata when it's redundant or readily available from other data sources, such as file names or external references.\n\n2. **Extract from Text:** When metadata is crucial but not in table form, you can extract information from text strings. For more information, refer to the section on string manipulation [@sec-string].\n\n3. **Read as a Second Table:** If metadata is well-organized in a tabular format, it can be read as a separate table to facilitate its use.\n\nIn the `Bachum_2763190000100.csv` file, you will find that there are 10 lines of metadata, which are well-organized in a tabular format. However, it's important to note that the consistency in values column varies.\n\n### Directly Ignore use grguments `skip`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# skip = 10\nread_csv2(fn_Bachum, skip = 10, n_max = 10, col_names = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 2\n   X1            X2\n   <chr>      <dbl>\n 1 01.01.1990  20.6\n 2 02.01.1990  19.0\n 3 03.01.1990  17.9\n 4 04.01.1990  16.8\n 5 05.01.1990  16.0\n 6 06.01.1990  14.8\n 7 07.01.1990  14.3\n 8 08.01.1990  14.0\n 9 09.01.1990  14.4\n10 10.01.1990  14.5\n```\n:::\n:::\n\n\n### read metadata as table\n\nTo read the first 10 lines of metadata, you can use the `n_max` setting with a value of `n_max = 10` in the `read_csv2()` function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_csv2(fn_Bachum, n_max = 10, col_names = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 2\n   X1                          X2             \n   <chr>                       <chr>          \n 1 \"Name\"                      \"Bachum\"       \n 2 \"Pegelnummer\"               \"2763190000100\"\n 3 \"Gew\\xe4sser\"               \"Ruhr\"         \n 4 \"Datum von\"                 \"01.01.1990\"   \n 5 \"Datum bis\"                 \"31.12.2022\"   \n 6 \"Parameter\"                 \"Abfluss\"      \n 7 \"Q Einheit\"                 \"m\\xb3/s\"      \n 8 \"Tagesmittelwerte\"           <NA>          \n 9 \"Pegelnullpunkt [m\\xfcNHN]\" \"146,83\"       \n10 \"Einzugsgebiet [km\\xb2]\"    \"1.532,02\"     \n```\n:::\n:::\n\n\nWhen directly reading all metadata into one table, you may encounter mixed data types. In the metadata, there are three data types:\n\n- Numeric: Examples include `Pegelnullpunkt` and `Einzugsgebiet`.\n- String: This category covers fields like `Name`, `Pegelnummer`, and others.\n- Date: Date values are present in columns like `Datum von` and `Datum bis`.\n\nIn a data frame (tibble), columns must have the same data type. Consequently, R will automatically convert them to a single data type, which is typically string.\n\nTo address this situation, you should specify the data type you want to read. For example, to read the date values in lines 4 and 5, you can use the following settings:\n1. `skip = 3` to skip the first three lines of metadata.\n2. `n_max = 2` to read the next two lines (lines 4 and 5) as date values.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# skip = 10\nread_csv2(fn_Bachum, skip = 3, n_max = 2, col_names = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  X1        X2        \n  <chr>     <chr>     \n1 Datum von 01.01.1990\n2 Datum bis 31.12.2022\n```\n:::\n:::\n\n\nUnfortunately, R may not always recognize date values correctly, so you may need to perform additional steps for conversion:\n\n1. **After Reading:** This involves transforming the data from its initial format to the desired date format within your R environment.\n\n2. **Set the Data Type by Reading:** Another approach is to set the data type while reading the data. \n\nTo address the issue of date recognition, you can set the `col_types` parameter to `\"cD\"` when reading the data. This informs the function that the first column contains `c`haracters (`c`) and the second column contains `D`ates (`D`).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# skip = 10\nread_csv2(fn_Bachum, skip = 3, n_max = 2, col_names = FALSE, col_types = \"cD\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  X1        X2    \n  <chr>     <date>\n1 Datum von NA    \n2 Datum bis NA    \n```\n:::\n:::\n\n\n\nUnfortunately, the default date format in R may not work for German-style dates like \"d.m.Y,\" as R primarily recognizes the \"Y-m-d\" format. To handle this, you can convert the dates using function `as.Date()` and specify the date format using the `format` argument, such as `format = \"%d.%m.%Y\"`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_Date <- read_csv2(fn_Bachum, skip = 3, n_max = 2, col_names = FALSE)\ndf_Date$X2 <- df_Date$X2 |> as.Date(format = \"%d.%m.%Y\")\ndf_Date\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  X1        X2        \n  <chr>     <date>    \n1 Datum von 1990-01-01\n2 Datum bis 2022-12-31\n```\n:::\n:::\n\n\n\n# Text & String {#sec-string}\n\nmore details ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}