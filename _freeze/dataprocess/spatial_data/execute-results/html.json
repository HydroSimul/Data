{
  "hash": "919321d7786e9cd9a32fb18d21260c0b",
  "result": {
    "markdown": "---\ntitle: \"Basic Manipulation\"\nexecute:\n  warning: false\n  error: false\nsidebar:\n  contents: auto\nnumber-sections: true\n---\n\n\n# Library `terra`\n\nThe `terra` package in R is a powerful and versatile package for working with geospatial data, including **vector** and **raster** data. It provides a wide range of functionality for reading, processing, analyzing, and visualizing spatial data. \n\nFor more in-depth information and resources on the terra package and spatial data science in R, you can explore the original website [Spatial Data Science](https://rspatial.org/spatial/index.html). \n\nFirstly load the library to the R space:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load the library\nlibrary(terra)\nlibrary(tidyverse)\n```\n:::\n\n\n# Creating spatial data manually\n\nCreating spatial data manually is not a common practice due to the typically large volumes of data required. However, by starting from scratch and creating spatial data manually, you can gain a deeper understanding of the **data's structure** and properties. This manual creation process helps you become more familiar with how spatial data is organized and can be a valuable learning exercise.\n\nThe examples provided here are just a few methods for manually creating spatial data. There are numerous ways to create spatial data in R with the `terra` package. You can refer to the package [documentation](https://cran.r-project.org/web/packages/terra/terra.pdf), specifically the `rast()` and `vect()` functions, to explore more advanced methods for creating and manipulating spatial data. \n\n## Vector\n\nAs introduced in the [section](basic_format.qmd#sec-spatialData), spatial vector data typically consists of three main components:\n\n- **Geometry**: Describes the spatial location and shape of features.\n- **Attributes**: Non-spatial properties associated with features.\n- **CRS** (Coordinate Reference System): Defines the spatial reference framework.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the coordinate reference system (CRS) with EPSG codes\ncrs_31468 <- \"EPSG:31468\"\n\n# Define coordinates for the first polygon\nx_polygon_1 <- c(4484566, 4483922, 4483002, 4481929, 4481222, 4482500, 4483000, 4484666, 4484233)\ny_polygon_1 <- c(5554566, 5554001, 5553233, 5554933, 5550666, 5551555, 5550100, 5551711, 5552767)\nxy_polygon_1 <- cbind(id=1, part=1, x_polygon_1, y_polygon_1)\n# Define coordinates for the second polygon\nx_polygon_2 <- c(4481929, 4481222, 4480500)\ny_polygon_2 <- c(5554933, 5550666, 5552555)\nxy_polygon_2 <- cbind(id=2, part=1, x_polygon_2, y_polygon_2)\n# Combine the two polygons into one data frame\nxy_polygon <- rbind(xy_polygon_1, xy_polygon_2)\n\n# Create a vector layer for the polygons, specifying their type, attributes, CRS, and additional attributes\nvect_Test <- vect(xy_polygon, type=\"polygons\", atts = data.frame(ID_region = 1:2, Name = c(\"a\", \"b\")), crs = crs_31468)\nvect_Test$region_area <- expanse(vect_Test)\n```\n:::\n\n\n\n\n## Raster\n\nFor raster data, the geometry is relatively simple and can be defined by the following components:\n\n- Coordinate of **Original Point** (X0, Y0) plus **Resolutions** (X and Y)\n- **Boundaries** (Xmin, Xmax, Ymin, Ymax) plus **Number of Rows and Columns**\n\n\nOne of the most critical aspects of raster data is the values stored within its cells. You can set or modify these values using the `values()<-` function in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrast_Test <- rast(ncol=10, nrow=10, xmin=-150, xmax=-80, ymin=20, ymax=60)\nvalues(rast_Test) <- runif(ncell(rast_Test))\n```\n:::\n\n\n\nCertainly, you can directly create a data file like an ASC (ASCII) file for raster data. \n\n![](../images/spatialdata_TestRaster.png)\n\n\n\n\n# Read and write\n\n**Reading** and **writing** data are fundamental processes that precede spatial data manipulation. Spatial data is typically acquired from external sources. \n\nHowever, due to the substantial differences between raster and vector data structures, they are often handled separately.\n\n| Data Type | Read | Write |\n|-----------|------|-------|\n| Vector    |`vect()`|`writeVect()`|\n| Raster    |`rast()`|`writeRast()`|\n\nThe test files are available in [Github](https://github.com/HydroSimul/Web/tree/main/data_share)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read shp-file as a vector layer\nvect_Test <- vect(\"https://raw.githubusercontent.com/HydroSimul/Web/main/data_share/minibeispiel_polygon.geojson\")\n# Read raster file\nrast_Test <- rast(\"https://raw.githubusercontent.com/HydroSimul/Web/main/data_share/minibeispiel_raster.asc\")\n\n# Info and Plot of vector layer\nvect_Test\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 2, 3  (geometries, attributes)\n extent      : 4480500, 4484666, 5550100, 5554933  (xmin, xmax, ymin, ymax)\n source      : minibeispiel_polygon.geojson\n coord. ref. : DHDN / 3-degree Gauss-Kruger zone 4 (EPSG:31468) \n names       : ID_region  Name region_area\n type        :     <int> <chr>       <num>\n values      :         1     a   8.853e+06\n                       2     b   2.208e+06\n```\n:::\n\n```{.r .cell-code}\nplot(vect_Test)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Info and Plot of raster layer\nrast_Test\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 5, 5, 1  (nrow, ncol, nlyr)\nresolution  : 1000, 1000  (x, y)\nextent      : 4480000, 4485000, 5550000, 5555000  (xmin, xmax, ymin, ymax)\ncoord. ref. :  \nsource      : minibeispiel_raster.asc \nname        : minibeispiel_raster \n```\n:::\n\n```{.r .cell-code}\nplot(rast_Test)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-4-2.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwriteVector(vect_Test, \"fn_Output_Vector.geojson\", \"GeoJSON\")\n\nwriteRaster(rast_Test, \"fn_OutPut_Raster.tif\")\n```\n:::\n\n\n\n# Coordinate Reference Systems\n\n## Assigning a CRS\n\nIn cases where the **Coordinate Reference System (CRS)** information is not included in the data file's content, you can assign it manually using the `crs()` function. This situation often occurs when working with raster data in formats like ASC (Arc/Info ASCII Grid) or other file formats that may not store CRS information.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrs(rast_Test) <- \"EPSG:31468\"\nrast_Test\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 5, 5, 1  (nrow, ncol, nlyr)\nresolution  : 1000, 1000  (x, y)\nextent      : 4480000, 4485000, 5550000, 5555000  (xmin, xmax, ymin, ymax)\ncoord. ref. : DHDN / 3-degree Gauss-Kruger zone 4 (EPSG:31468) \nsource      : minibeispiel_raster.asc \nname        : minibeispiel_raster \n```\n:::\n:::\n\n\n\nAs the results showed, the CRS information has been filled with the necessary details in line `coord. ref.`. \n\n\nThe use of **EPSG (European Petroleum Survey Group) codes** is highly recommended for defining Coordinate Reference Systems (CRS) in spatial data. You can obtain information about EPSG codes from the [EPSG](https://epsg.io/) website. \n\n::: {.callout-important}\n## NOTE\n\nYou should not use this approach to change the CRS of a data set from what it is to what you want it to be. Assigning a CRS is like labeling something.\n:::\n\n\n## Transforming vector data\n\nThe **transformation** of vector data is relatively simple, as it involves applying a mathematical formula to the coordinates of each point to obtain their new coordinates. This transformation can be considered as **without loss of precision**. \n\nThe `project()` function can be utilized to **reproject** both vector and raster data. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# New CRS\ncrs_New <- \"EPSG:4326\"\n# Reproject\nvect_Test_New <- project(vect_Test, crs_New)\n\n# Info and Plot of vector layer\nvect_Test_New\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 2, 3  (geometries, attributes)\n extent      : 11.72592, 11.78419, 50.08692, 50.13034  (xmin, xmax, ymin, ymax)\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       : ID_region  Name region_area\n type        :     <int> <chr>       <num>\n values      :         1     a   8.853e+06\n                       2     b   2.208e+06\n```\n:::\n:::\n\n\n\n## Transforming raster data\n\nVector data can be transformed from lon/lat coordinates to planar and back without loss of precision. This is not the case with raster data. A raster consists of rectangular **cells** of the same size (in terms of the units of the CRS; their actual size may vary).\nIt is not possible to transform cell by cell. For each new cell, values need to be **estimated** based on the values in the overlapping old cells. If the values are categorical data, the **“nearest neighbor”** method is commonly used. Otherwise some sort of interpolation is employed (e.g. **“bilinear”**).  (From [Spatial Data Science](https://rspatial.org/spatial/6-crs.html))\n\n::: {.callout-note}\nBecause projection of rasters affects the cell values, in most cases you will want to avoid projecting raster data and rather project vector data. \n:::\n\n### With CRS\n\nThe simplest approach is to provide a **new CRS**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# New CRS\ncrs_New <- \"EPSG:4326\"\n# Reproject\nrast_Test_New <- project(rast_Test, crs_New)\n\n# Info and Plot of vector layer\nrast_Test_New\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 4, 6, 1  (nrow, ncol, nlyr)\nresolution  : 0.01176853, 0.01176853  (x, y)\nextent      : 11.7188, 11.78941, 50.08395, 50.13102  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource(s)   : memory\nname        : minibeispiel_raster \nmin value   :            1.000000 \nmax value   :            2.586555 \n```\n:::\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot(rast_Test)\n```\n\n::: {.cell-output-display}\n![Original](spatial_data_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(rast_Test_New)\n```\n\n::: {.cell-output-display}\n![New](spatial_data_files/figure-html/unnamed-chunk-9-2.png){width=672}\n:::\n:::\n\n\n### With Mask Raster\n\nA second way is provide an existing `SpatRaster` with the **geometry you desire**, with special boundary and resolution, this is a better way.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# New CRS\nrast_Mask <- rast(ncol=10, nrow=10, xmin=265000, xmax=270000, ymin=5553000, ymax=5558000)\ncrs(rast_Mask) <- \"EPSG:25833\"\nvalues(rast_Mask) <- 1\n# Reproject\nrast_Test_New <- project(rast_Test, rast_Mask)\n\n# Info and Plot of vector layer\nrast_Test_New\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 10, 10, 1  (nrow, ncol, nlyr)\nresolution  : 500, 500  (x, y)\nextent      : 265000, 270000, 5553000, 5558000  (xmin, xmax, ymin, ymax)\ncoord. ref. : ETRS89 / UTM zone 33N (EPSG:25833) \nsource(s)   : memory\nname        : minibeispiel_raster \nmin value   :                   1 \nmax value   :                   3 \n```\n:::\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot(rast_Test)\n```\n\n::: {.cell-output-display}\n![Original](spatial_data_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(rast_Test_New)\n```\n\n::: {.cell-output-display}\n![New](spatial_data_files/figure-html/unnamed-chunk-11-2.png){width=672}\n:::\n:::\n\n\n# Vector data manipulation\n\nIn vector manipulation, it's crucial to handle both attributes and **shapes**, especially when combining multiple shapes or layers with other shapes and addressing overlapping layers.\n\n\n## Attributes manipulation\n\n### Extract all Attributes\n\n- `as.data.frame()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_Attr <- as.data.frame(vect_Test)\ndf_Attr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  ID_region Name region_area\n1         1    a     8853404\n2         2    b     2208109\n```\n:::\n:::\n\n\n### Extract one with attribute name\n\n- `$name`\n- `[, \"name\"]`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Test$ID_region\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n\n```{.r .cell-code}\nvect_Test[,\"ID_region\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 2, 1  (geometries, attributes)\n extent      : 4480500, 4484666, 5550100, 5554933  (xmin, xmax, ymin, ymax)\n source      : minibeispiel_polygon.geojson\n coord. ref. : DHDN / 3-degree Gauss-Kruger zone 4 (EPSG:31468) \n names       : ID_region\n type        :     <int>\n values      :         1\n                       2\n```\n:::\n:::\n\n\n### Add a new attribute\n\n- `$name <- `\n- `[, \"name\"] <- `\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Test$New_Attr <- c(\"n1\", \"n2\")\nvect_Test[,\"New_Attr\"] <- c(\"n1\", \"n2\")\n```\n:::\n\n\n\n### Merge several attributes\n\n- same order\n  - `cbind()`\n- common (key-)attributes\n  - `merge()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_New_Attr <- data.frame(Name = c(\"a\", \"b\"), new_Attr2 = c(9, 6))\n\ncbind(vect_Test, df_New_Attr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 2, 6  (geometries, attributes)\n extent      : 4480500, 4484666, 5550100, 5554933  (xmin, xmax, ymin, ymax)\n source      : minibeispiel_polygon.geojson\n coord. ref. : DHDN / 3-degree Gauss-Kruger zone 4 (EPSG:31468) \n names       : ID_region  Name region_area New_Attr  Name new_Attr2\n type        :     <int> <chr>       <num>    <chr> <chr>     <num>\n values      :         1     a   8.853e+06       n1     a         9\n                       2     b   2.208e+06       n2     b         6\n```\n:::\n\n```{.r .cell-code}\nmerge(vect_Test, df_New_Attr, by = \"Name\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 2, 5  (geometries, attributes)\n extent      : 4480500, 4484666, 5550100, 5554933  (xmin, xmax, ymin, ymax)\n coord. ref. : DHDN / 3-degree Gauss-Kruger zone 4 (EPSG:31468) \n names       :  Name ID_region region_area New_Attr new_Attr2\n type        : <chr>     <int>       <num>    <chr>     <num>\n values      :     a         1   8.853e+06       n1         9\n                   b         2   2.208e+06       n2         6\n```\n:::\n:::\n\n\n\n\n### Delete a attribute\n\n- `$name <- NULL`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Test$New_Attr <- c(\"n1\", \"n2\")\nvect_Test[,\"New_Attr\"] <- c(\"n1\", \"n2\")\n```\n:::\n\n\n## Object Append and aggregate\n\n### Append new Objects\n\n- `rbind()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# New Vect\n# Define the coordinate reference system (CRS) with EPSG codes\ncrs_31468 <- \"EPSG:31468\"\n\n# Define coordinates for the first polygon\nx_polygon_3 <- c(4480400, 4481222, 4480500)\ny_polygon_3 <- c(5551000, 5550666, 5552555)\nxy_polygon_3 <- cbind(id=3, part=1, x_polygon_3, y_polygon_3)\n\n# Create a vector layer for the polygons, specifying their type, attributes, CRS, and additional attributes\nvect_New <- vect(xy_polygon_3, type=\"polygons\", atts = data.frame(ID_region = 3, Name = c(\"b\")), crs = crs_31468)\nvect_New$region_area <- expanse(vect_New)\n\n# Append the objects\nvect_Append <- rbind(vect_Test, vect_New)\nvect_Append\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 3, 4  (geometries, attributes)\n extent      : 4480400, 4484666, 5550100, 5554933  (xmin, xmax, ymin, ymax)\n source      : minibeispiel_polygon.geojson\n coord. ref. : DHDN / 3-degree Gauss-Kruger zone 4 (EPSG:31468) \n names       : ID_region  Name region_area New_Attr\n type        :     <int> <chr>       <num>    <chr>\n values      :         1     a   8.853e+06       n1\n                       2     b   2.208e+06       n2\n                       3     b   6.558e+05       NA\n```\n:::\n:::\n\n\n\n### Aggregate / Dissolve\n\nIt is common to **aggregate (“dissolve”)** polygons that have the same value for an attribute of interest. \n\n- `aggregate()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Aggregated <- terra::aggregate(vect_Append, by = \"Name\")\nvect_Aggregated\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 2, 5  (geometries, attributes)\n extent      : 4480400, 4484666, 5550100, 5554933  (xmin, xmax, ymin, ymax)\n coord. ref. : DHDN / 3-degree Gauss-Kruger zone 4 (EPSG:31468) \n names       :  Name mean_ID_region mean_region_area New_Attr agg_n\n type        : <chr>          <num>            <num>    <chr> <int>\n values      :     a              1        8.853e+06       n1     1\n                   b            2.5        1.432e+06       NA     2\n```\n:::\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot(vect_Append, \"ID_region\")\n```\n\n::: {.cell-output-display}\n![Original](spatial_data_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(vect_Aggregated, \"Name\")\n```\n\n::: {.cell-output-display}\n![Aggregated](spatial_data_files/figure-html/unnamed-chunk-19-2.png){width=672}\n:::\n:::\n\n\n## Overlap\n\nTo perform operations that involve overlap between two vector datasets, we will create a new vector dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Overlap <- as.polygons(rast_Test)[1,]\nnames(vect_Overlap) <- \"ID_Rast\"\n\nplot(vect_Overlap, \"ID_Rast\")\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\n### Erase\n\n- `erase()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Erase <- erase(vect_Test, vect_Overlap)\nplot(vect_Erase, \"ID_region\")\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\n### Intersect\n\n- `intersect()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Intersect <- terra::intersect(vect_Test, vect_Overlap)\nplot(vect_Intersect, \"ID_region\")\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n### Union\n\nAppends the geometries and attributes of the input. \n\n- `union()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Union <- terra::union(vect_Test, vect_Overlap)\nplot(vect_Union, \"ID_region\")\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n### Cover\n\n`cover()` is a combination of `intersect()` and `union()`. intersect returns new (intersected) geometries with the attributes of both input datasets. union appends the geometries and attributes of the input. cover returns the intersection and appends the other geometries and attributes of both datasets.\n\n\n- `cover()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Cover <- terra::cover(vect_Test, vect_Overlap)\nplot(vect_Cover, \"ID_region\")\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\n\n\n### Difference\n\n- `symdif()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Difference <- terra::symdif(vect_Test, vect_Overlap)\nplot(vect_Difference, \"ID_region\")\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n# Raster data manipulation\n\nCompared to vector data, raster data stores **continuous numeric** values more, leading to significant differences in manipulation and analysis approaches.\n\n\n## Raster algebra\n\nMany generic functions that allow for simple and elegant raster **algebra** have been implemented for Raster objects, including the normal algebraic operators such as `+`, `-`, `*`, `/`, logical operators such as `>`, `>=`, `<`, `==`, `!`, and functions like `abs`, `round`, `ceiling`, `floor`, `trunc`, `sqrt`, `log`, `log10`, `exp`, `cos`, `sin`, `atan`, `tan`, `max`, `min`, `range`, `prod`, `sum`, `any`, `all`. In these functions, you can mix raster objects with numbers, as long as the first argument is a raster object. ([Spatial Data Science](https://rspatial.org/spatial/index.html))\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrast_Add <- rast_Test + 10\nplot(rast_Add)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n## Replace with Condition\n\n- `rast[condition] <- `\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Copy to a new raster\nrast_Replace <- rast_Test\n\n# Replace\nrast_Replace[rast_Replace > 1] <- 10\nplot(rast_Replace)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n## Summary of multi-layers\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrast_Mean <- mean(rast_Test, rast_Replace)\nplot(rast_Mean)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n## Aggregate and disaggregate\n\n- `aggregate()`\n- `disagg()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrast_Aggregate <- aggregate(rast_Test, 2)\nplot(rast_Aggregate)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrast_Disagg <- disagg(rast_Test, 2)\nrast_Disagg\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 10, 10, 1  (nrow, ncol, nlyr)\nresolution  : 500, 500  (x, y)\nextent      : 4480000, 4485000, 5550000, 5555000  (xmin, xmax, ymin, ymax)\ncoord. ref. : DHDN / 3-degree Gauss-Kruger zone 4 (EPSG:31468) \nsource(s)   : memory\nname        : minibeispiel_raster \nmin value   :                   1 \nmax value   :                   3 \n```\n:::\n\n```{.r .cell-code}\nplot(rast_Disagg)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n\n## Crop\n\nThe crop function lets you take a geographic **subset** of a larger raster object with an **extent**. But you can also use other spatial object, in them an extent can be extracted.\n\n- `crop()`\n  - with extention\n  - with rster\n  - with vector\n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrast_Crop <- crop(rast_Test, vect_Test[1,])\nplot(rast_Crop)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\n\n## Trim\n\n- `trim()`\n\nTrim (shrink) a `SpatRaster` by **removing outer rows and columns** that are NA or another value.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrast_Trim0 <- rast_Test\nrast_Trim0[21:25] <- NA\nrast_Trim <- trim(rast_Trim0)\n```\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot(rast_Trim0)\n```\n\n::: {.cell-output-display}\n![with NA](spatial_data_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(rast_Trim)\n```\n\n::: {.cell-output-display}\n![Trimed](spatial_data_files/figure-html/unnamed-chunk-33-2.png){width=672}\n:::\n:::\n\n\n\n## Mask\n\n- `mask()`\n- `crop(mask = TRUE)` = `mask()` + `trim()`\n\nWhen you use mask manipulation in spatial data analysis, it involves setting the cells that are **not covered** by a mask to NA (Not Available) values. If you apply the `crop(mask = TRUE)` operation, it means that not only will the cells outside of the mask be set to NA, but the resulting raster will also be cropped to match the extent of the mask.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrast_Mask <- mask(rast_Disagg, vect_Test[1,])\nrast_CropMask <- crop(rast_Disagg, vect_Test[1,], mask = TRUE)\n```\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot(rast_Mask)\n```\n\n::: {.cell-output-display}\n![Mask](spatial_data_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(rast_CropMask)\n```\n\n::: {.cell-output-display}\n![Mask + Crop (Trim)](spatial_data_files/figure-html/unnamed-chunk-35-2.png){width=672}\n:::\n:::\n",
    "supporting": [
      "spatial_data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}