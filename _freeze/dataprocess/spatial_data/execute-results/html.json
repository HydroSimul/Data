{
  "hash": "d4a2867c97b2245efbdb52e701412ba4",
  "result": {
    "markdown": "---\ntitle: \"Basic Manipulation\"\nexecute:\n  warning: false\n  error: false\nsidebar:\n  contents: auto\nnumber-sections: true\n---\n\n\n# Library `terra`\n\n::: {.panel-tabset}\n\n## R\n\n\n\nThe `terra` package in R is a powerful and versatile package for working with geospatial data, including **vector** and **raster** data. It provides a wide range of functionality for reading, processing, analyzing, and visualizing spatial data. \n\nFor more in-depth information and resources on the terra package and spatial data science in R, you can explore the original website [Spatial Data Science](https://rspatial.org/spatial/index.html). \n\nFirstly load the library to the R space:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load the library\nlibrary(terra)\nlibrary(tidyverse)\n```\n:::\n\n\n## Python\n\nThe libraries for spatial data in Python are divided into several libraries, unlike the comprehensive 'terra' library in R. For vector data, you can use the 'geopandas' library, and for raster data, 'rasterio' is a good choice, among others.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport os\nimport pandas as pd\nimport numpy as np\n# Vector\nimport geopandas as gpd\nfrom shapely.geometry import Point, LineString, Polygon, shape\nimport fiona\n\n# Rster\nimport rasterio\nfrom rasterio.plot import show as rast_plot\nfrom rasterio.crs import CRS\nfrom rasterio.warp import calculate_default_transform, reproject, Resampling\nimport rasterio.features\nfrom rasterio.enums import Resampling\n\n# Plot\nimport matplotlib.pyplot as plt\n```\n:::\n\n\n:::\n\n\n# Creating spatial data manually\n\nCreating spatial data manually is not a common practice due to the typically large volumes of data required. However, by starting from scratch and creating spatial data manually, you can gain a deeper understanding of the **data's structure** and properties. This manual creation process helps you become more familiar with how spatial data is organized and can be a valuable learning exercise.\n\nThe examples provided here are just a few methods for manually creating spatial data. There are numerous ways to create spatial data in R with the `terra` package. You can refer to the package [documentation](https://cran.r-project.org/web/packages/terra/terra.pdf), specifically the `rast()` and `vect()` functions, to explore more advanced methods for creating and manipulating spatial data. \n\n## Vector\n\nAs introduced in the [section](basic_format.qmd#sec-spatialData), spatial vector data typically consists of three main components:\n\n- **Geometry**: Describes the spatial location and shape of features.\n- **Attributes**: Non-spatial properties associated with features.\n- **CRS** (Coordinate Reference System): Defines the spatial reference framework.\n\n::: {.panel-tabset}\n\n## R\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the coordinate reference system (CRS) with EPSG codes\ncrs_31468 <- \"EPSG:31468\"\n\n# Define coordinates for the first polygon\nx_polygon_1 <- c(4484566, 4483922, 4483002, 4481929, 4481222, 4482500, 4483000, 4484666, 4484233)\ny_polygon_1 <- c(5554566, 5554001, 5553233, 5554933, 5550666, 5551555, 5550100, 5551711, 5552767)\ngeometry_polygon_1 <- cbind(id=1, part=1, x_polygon_1, y_polygon_1)\n# Define coordinates for the second polygon\nx_polygon_2 <- c(4481929, 4481222, 4480500)\ny_polygon_2 <- c(5554933, 5550666, 5552555)\ngeometry_polygon_2 <- cbind(id=2, part=1, x_polygon_2, y_polygon_2)\n# Combine the two polygons into one data frame\ngeometry_polygon <- rbind(geometry_polygon_1, geometry_polygon_2)\n\n# Create a vector layer for the polygons, specifying their type, attributes, CRS, and additional attributes\nvect_Test <- vect(geometry_polygon, type=\"polygons\", \n                  atts = data.frame(ID_region = 1:2, Name = c(\"a\", \"b\")), \n                  crs = crs_31468)\nvect_Test$region_area <- expanse(vect_Test)\n\n# Visualize the created polygons\nplot(vect_Test)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Define the coordinate reference system (CRS) with EPSG codes\ncrs_31468 = \"EPSG:31468\"\n\n# Define coordinates for the first polygon\nx_polygon_1 = [4484566, 4483922, 4483002, 4481929, 4481222, 4482500, 4483000, 4484666, 4484233]\ny_polygon_1 = [5554566, 5554001, 5553233, 5554933, 5550666, 5551555, 5550100, 5551711, 5552767]\n# Create a list of coordinate pairs for the first polygon\ngeometry_polygon_1 = Polygon([(x, y) for x, y in zip(x_polygon_1, y_polygon_1)])\n\n# Define coordinates for the second polygon\nx_polygon_2 = [4481929, 4481222, 4480500]\ny_polygon_2 = [5554933, 5550666, 5552555]\n# Create a list of coordinate pairs for the second polygon\ngeometry_polygon_2 = Polygon([(x, y) for x, y in zip(x_polygon_2, y_polygon_2)])\n\n# Construct Shapely polygons using the lists of coordinates\ngeometry_polygon = [geometry_polygon_1, geometry_polygon_2]\n\n\n# Create a GeoDataFrame with the polygons, specifying their attributes, CRS, and additional attributes\nvect_Test = gpd.GeoDataFrame({\n    'ID_region': [1, 2],\n    'Name': ['a', 'b'],\n    'geometry': geometry_polygon,\n}, crs=crs_31468)\n\n# Calculate the region area and add it as a new column\nvect_Test['region_area'] = vect_Test.area\n\n# Visualize the created polygons\nvect_Test.plot()\nplt.show()\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n\n```{.python .cell-code}\nplt.close()\n```\n:::\n\n\n:::\n\n\n\n\n## Raster\n\nFor raster data, the geometry is relatively simple and can be defined by the following components:\n\n- Coordinate of **Original Point** (X0, Y0) plus **Resolutions** (X and Y)\n- **Boundaries** (Xmin, Xmax, Ymin, Ymax) plus **Number of Rows and Columns**\n\n\nOne of the most critical aspects of raster data is the values stored within its cells. You can set or modify these values using the `values()<-` function in R.\n\n\n::: {.panel-tabset}\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrast_Test <- rast(ncol=10, nrow=10, xmin=-150, xmax=-80, ymin=20, ymax=60)\nvalues(rast_Test) <- runif(ncell(rast_Test))\n\nplot(rast_Test)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-5-3.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfn_Rster_Test = \"C:\\\\Lei\\\\HS_Web\\\\data_share/raster_Py.tif\"\n\n# Create a new raster with the specified dimensions and extent\nncol, nrow = 10, 10\nxmin, xmax, ymin, ymax = -150, -80, 20, 60\n\n# Create the empty raster with random values\nwith rasterio.open(\n    fn_Rster_Test,\n    \"w\",\n    driver=\"GTiff\",\n    dtype=np.float32,\n    count=1,\n    width=ncol,\n    height=nrow,\n    transform=rasterio.transform.from_origin(xmin, ymax, (xmax - xmin) / ncol, (ymax - ymin) / nrow),\n    crs=\"EPSG:4326\"\n) as dst:\n    # Generate random values and assign them to the raster\n    random_values = np.random.rand(nrow, ncol).astype(np.float32)\n    dst.write(random_values, 1)  # Write the values to band 1\n\n# Now you have an empty raster with random values, and you can read and manipulate it as needed\nwith rasterio.open(fn_Rster_Test) as src:\n    rast_Test = src.read(1)\n\n\nrast_plot(rast_Test)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n:::\n\n\n\nCertainly, you can directly create a data file like an ASC (ASCII) file for raster data. \n\n![](../images/spatialdata_TestRaster.png)\n\n\n\n\n# Read and write\n\n**Reading** and **writing** data are fundamental processes that precede spatial data manipulation. Spatial data is typically acquired from external sources. \n\nThe test files are available in [Github](https://github.com/HydroSimul/Web/tree/main/data_share)\n\nHowever, due to the substantial differences between raster and vector data structures, they are often handled separately.\n\n\n::: {.panel-tabset}\n\n## R\n\n| Data Type | Read | Write |\n|-----------|------|-------|\n| Vector    |`vect()`|`writeVect()`|\n| Raster    |`rast()`|`writeRast()`|\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read shp-file as a vector layer\nvect_Test <- vect(\"https://raw.githubusercontent.com/HydroSimul/Web/main/data_share/minibeispiel_polygon.geojson\")\n\n# Read raster file\nrast_Test <- rast(\"https://raw.githubusercontent.com/HydroSimul/Web/main/data_share/minibeispiel_raster.asc\")\n\n# Info and Plot of vector layer\nvect_Test\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 2, 3  (geometries, attributes)\n extent      : 4480500, 4484666, 5550100, 5554933  (xmin, xmax, ymin, ymax)\n source      : minibeispiel_polygon.geojson\n coord. ref. : DHDN / 3-degree Gauss-Kruger zone 4 (EPSG:31468) \n names       : ID_region  Name region_area\n type        :     <int> <chr>       <num>\n values      :         1     a   8.853e+06\n                       2     b   2.208e+06\n```\n:::\n\n```{.r .cell-code}\nplot(vect_Test)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-7-3.png){width=672}\n:::\n\n```{.r .cell-code}\n# Info and Plot of raster layer\nrast_Test\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 5, 5, 1  (nrow, ncol, nlyr)\nresolution  : 1000, 1000  (x, y)\nextent      : 4480000, 4485000, 5550000, 5555000  (xmin, xmax, ymin, ymax)\ncoord. ref. :  \nsource      : minibeispiel_raster.asc \nname        : minibeispiel_raster \n```\n:::\n\n```{.r .cell-code}\nplot(rast_Test)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-7-4.png){width=672}\n:::\n:::\n\n\nExport:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfn_Vect_Out = \"fn_Output_Vector.geojson\"\nwriteVector(vect_Test, fn_Vect_Out, \"GeoJSON\")\n\nfn_Rast_Out = \"fn_OutPut_Raster.tif\"\nwriteRaster(rast_Test, fn_Rast_Out)\n```\n:::\n\n\n## Python\n\n| Data Type | Read | Write |\n|-----------|------|-------|\n| Vector    |`geopandas.read_file()`|`geopandas.to_file()`|\n| Raster    |`rastio.open()`|`rastio.open()`|\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Read GeoJSON file as a vector layer\nvect_Test = gpd.read_file(\"https://raw.githubusercontent.com/HydroSimul/Web/main/data_share/minibeispiel_polygon.geojson\")\n\n# Read raster file\nrast_Test = rasterio.open(\"https://raw.githubusercontent.com/HydroSimul/Web/main/data_share/minibeispiel_raster.asc\")\n\n# Info and Plot of the vector layer\nprint(vect_Test)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   ID_region  ...                                           geometry\n0          1  ...  MULTIPOLYGON (((4484566.000 5554566.000, 44839...\n1          2  ...  MULTIPOLYGON (((4481929.000 5554933.000, 44812...\n\n[2 rows x 4 columns]\n```\n:::\n\n```{.python .cell-code}\nvect_Test.plot()\nplt.show()\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n\n```{.python .cell-code}\nplt.close()\n\n# Info and Plot of the raster layer\nprint(rast_Test.profile)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'driver': 'AAIGrid', 'dtype': 'float32', 'nodata': -9999.0, 'width': 5, 'height': 5, 'count': 1, 'crs': None, 'transform': Affine(1000.0, 0.0, 4480000.0,\n       0.0, -1000.0, 5555000.0), 'blockysize': 1, 'tiled': False}\n```\n:::\n\n```{.python .cell-code}\nrast_plot(rast_Test)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-9-2.png){width=672}\n:::\n:::\n\n\n\nExport:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfn_Vect_Out = \"fn_Output_Vector.geojson\"\nvect_Test.to_file(fn_Vect_Out, driver=\"GeoJSON\")\n\n# Write the raster to a GeoTIFF file\nfn_Rast_Out = \"fn_OutPut_Raster.tif\"\nwith rasterio.open(fn_Rast_Out, 'w', driver='GTiff', dtype=rast_Test.dtype, count=1, width=rast_Test.shape[1], height=rast_Test.shape[0], transform=rast_Test.transform, crs=rast_Test.crs) as dst:\n    dst.write(rast_Test, 1)\n```\n:::\n\n\n:::\n\n\n\n\n# Coordinate Reference Systems\n\n## Assigning a CRS\n\nIn cases where the **Coordinate Reference System (CRS)** information is not included in the data file's content, you can assign it manually using the `crs()` function. This situation often occurs when working with raster data in formats like ASC (Arc/Info ASCII Grid) or other file formats that may not store CRS information.\n\n::: {.panel-tabset}\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrs(rast_Test) <- \"EPSG:31468\"\nrast_Test\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 5, 5, 1  (nrow, ncol, nlyr)\nresolution  : 1000, 1000  (x, y)\nextent      : 4480000, 4485000, 5550000, 5555000  (xmin, xmax, ymin, ymax)\ncoord. ref. : DHDN / 3-degree Gauss-Kruger zone 4 (EPSG:31468) \nsource      : minibeispiel_raster.asc \nname        : minibeispiel_raster \n```\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nrast_Test = rasterio.open(\"https://raw.githubusercontent.com/HydroSimul/Web/main/data_share/minibeispiel_raster.asc\", 'r+')\nrast_Test.crs = CRS.from_epsg(31468)\nprint(rast_Test.crs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEPSG:31468\n```\n:::\n:::\n\n\n:::\n\n\n\n\nAs the results showed, the CRS information has been filled with the necessary details in line `coord. ref.`. \n\n\nThe use of **EPSG (European Petroleum Survey Group) codes** is highly recommended for defining Coordinate Reference Systems (CRS) in spatial data. You can obtain information about EPSG codes from the [EPSG](https://epsg.io/) website. \n\n::: {.callout-important}\n## NOTE\n\nYou should not use this approach to change the CRS of a data set from what it is to what you want it to be. Assigning a CRS is like labeling something.\n:::\n\n\n## Transforming vector data\n\nThe **transformation** of vector data is relatively simple, as it involves applying a mathematical formula to the coordinates of each point to obtain their new coordinates. This transformation can be considered as **without loss of precision**. \n\n::: {.panel-tabset}\n\n## R\n\nThe `project()` function can be utilized to **reproject** both vector and raster data. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# New CRS\ncrs_New <- \"EPSG:4326\"\n# Reproject\nvect_Test_New <- project(vect_Test, crs_New)\n\n# Info of vector layer\nvect_Test_New\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 2, 3  (geometries, attributes)\n extent      : 11.72592, 11.78419, 50.08692, 50.13034  (xmin, xmax, ymin, ymax)\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       : ID_region  Name region_area\n type        :     <int> <chr>       <num>\n values      :         1     a   8.853e+06\n                       2     b   2.208e+06\n```\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ncrs_New = \"EPSG:4326\"\n\n# Reproject the vector layer to the new CRS\nvect_Test_New = vect_Test.to_crs(crs=crs_New)\n\n# Info of vector layer\nprint(vect_Test_New)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   ID_region  ...                                           geometry\n0          1  ...  MULTIPOLYGON (((11.78268 50.12711, 11.77370 50...\n1          2  ...  MULTIPOLYGON (((11.74578 50.13033, 11.73611 50...\n\n[2 rows x 4 columns]\n```\n:::\n:::\n\n\n:::\n\n\n\n## Transforming raster data\n\nVector data can be transformed from lon/lat coordinates to planar and back without loss of precision. This is not the case with raster data. A raster consists of rectangular **cells** of the same size (in terms of the units of the CRS; their actual size may vary).\nIt is not possible to transform cell by cell. For each new cell, values need to be **estimated** based on the values in the overlapping old cells. If the values are categorical data, the **“nearest neighbor”** method is commonly used. Otherwise some sort of interpolation is employed (e.g. **“bilinear”**).  (From [Spatial Data Science](https://rspatial.org/spatial/6-crs.html))\n\n::: {.callout-note}\nBecause projection of rasters affects the cell values, in most cases you will want to avoid projecting raster data and rather project vector data. \n:::\n\n### With CRS\n\nThe simplest approach is to provide a **new CRS**:\n\n::: {.panel-tabset}\n\n## R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# New CRS\ncrs_New <- \"EPSG:4326\"\n# Reproject\nrast_Test_New <- project(rast_Test, crs_New, method = 'near')\n\n# Info and Plot of vector layer\nrast_Test_New\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 4, 6, 1  (nrow, ncol, nlyr)\nresolution  : 0.01176853, 0.01176853  (x, y)\nextent      : 11.7188, 11.78941, 50.08395, 50.13102  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource(s)   : memory\nname        : minibeispiel_raster \nmin value   :                   1 \nmax value   :                   3 \n```\n:::\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot(rast_Test)\n```\n\n::: {.cell-output-display}\n![Original](spatial_data_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(rast_Test_New)\n```\n\n::: {.cell-output-display}\n![New](spatial_data_files/figure-html/unnamed-chunk-16-2.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfn_Rast_New = 'C:\\\\Lei\\\\HS_Web\\\\data_share/minibeispiel_raster.tif'\n# Define the new CRS\nnew_crs = {'init': 'EPSG:4326'}\ntransform, width, height = calculate_default_transform(\n        rast_Test.crs, new_crs, rast_Test.width, rast_Test.height, *rast_Test.bounds)\nkwargs = rast_Test.meta.copy()\nkwargs.update({\n        'crs': new_crs,\n        'transform': transform,\n        'width': width,\n        'height': height\n    })        \nrast_Test_New = rasterio.open(fn_Rast_New, 'w', **kwargs)        \nreproject(\n    source=rasterio.band(rast_Test, 1),\n    destination=rasterio.band(rast_Test_New, 1),\n    #src_transform=rast_Test.transform,\n    src_crs=rast_Test.crs,\n    #dst_transform=transform,\n    dst_crs=new_crs,\n    resampling=Resampling.nearest)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Band(ds=<open BufferedDatasetWriter name='C:/Lei/HS_Web/data_share/minibeispiel_raster.tif' mode='w'>, bidx=1, dtype='float32', shape=(4, 6)), None)\n```\n:::\n\n```{.python .cell-code}\nrast_Test_New.close()        \n\nrast_Test = rasterio.open(\"https://raw.githubusercontent.com/HydroSimul/Web/main/data_share/minibeispiel_raster.asc\")\nrast_plot(rast_Test)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n\n```{.python .cell-code}\nrast_Test_New = rasterio.open(fn_Rast_New)\nrast_plot(rast_Test_New)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-17-2.png){width=672}\n:::\n:::\n\n\n\n:::\n\n\n### With Mask Raster\n\nA second way is provide an existing `SpatRaster` with the **geometry you desire**, with special boundary and resolution, this is a better way.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# New CRS\nrast_Mask <- rast(ncol=10, nrow=10, xmin=265000, xmax=270000, ymin=5553000, ymax=5558000)\ncrs(rast_Mask) <- \"EPSG:25833\"\nvalues(rast_Mask) <- 1\n# Reproject\nrast_Test_New <- project(rast_Test, rast_Mask)\n\n# Info and Plot of vector layer\nrast_Test_New\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 10, 10, 1  (nrow, ncol, nlyr)\nresolution  : 500, 500  (x, y)\nextent      : 265000, 270000, 5553000, 5558000  (xmin, xmax, ymin, ymax)\ncoord. ref. : ETRS89 / UTM zone 33N (EPSG:25833) \nsource(s)   : memory\nname        : minibeispiel_raster \nmin value   :                   1 \nmax value   :                   3 \n```\n:::\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot(rast_Test)\n```\n\n::: {.cell-output-display}\n![Original](spatial_data_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(rast_Test_New)\n```\n\n::: {.cell-output-display}\n![New](spatial_data_files/figure-html/unnamed-chunk-19-2.png){width=672}\n:::\n:::\n\n\n# Vector data manipulation\n\nIn vector manipulation, it's crucial to handle both attributes and **shapes**, especially when combining multiple shapes or layers with other shapes and addressing overlapping layers.\n\n\n## Attributes manipulation\n\n### Extract all Attributes\n\n- `as.data.frame()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_Attr <- as.data.frame(vect_Test)\ndf_Attr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  ID_region Name region_area\n1         1    a     8853404\n2         2    b     2208109\n```\n:::\n:::\n\n\n### Extract one with attribute name\n\n- `$name`\n- `[, \"name\"]`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Test$ID_region\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2\n```\n:::\n\n```{.r .cell-code}\nvect_Test[,\"ID_region\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 2, 1  (geometries, attributes)\n extent      : 4480500, 4484666, 5550100, 5554933  (xmin, xmax, ymin, ymax)\n source      : minibeispiel_polygon.geojson\n coord. ref. : DHDN / 3-degree Gauss-Kruger zone 4 (EPSG:31468) \n names       : ID_region\n type        :     <int>\n values      :         1\n                       2\n```\n:::\n:::\n\n\n### Add a new attribute\n\n- `$name <- `\n- `[, \"name\"] <- `\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Test$New_Attr <- c(\"n1\", \"n2\")\nvect_Test[,\"New_Attr\"] <- c(\"n1\", \"n2\")\n```\n:::\n\n\n\n### Merge several attributes\n\n- same order\n  - `cbind()`\n- common (key-)attributes\n  - `merge()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_New_Attr <- data.frame(Name = c(\"a\", \"b\"), new_Attr2 = c(9, 6))\n\ncbind(vect_Test, df_New_Attr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 2, 6  (geometries, attributes)\n extent      : 4480500, 4484666, 5550100, 5554933  (xmin, xmax, ymin, ymax)\n source      : minibeispiel_polygon.geojson\n coord. ref. : DHDN / 3-degree Gauss-Kruger zone 4 (EPSG:31468) \n names       : ID_region  Name region_area New_Attr  Name new_Attr2\n type        :     <int> <chr>       <num>    <chr> <chr>     <num>\n values      :         1     a   8.853e+06       n1     a         9\n                       2     b   2.208e+06       n2     b         6\n```\n:::\n\n```{.r .cell-code}\nmerge(vect_Test, df_New_Attr, by = \"Name\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 2, 5  (geometries, attributes)\n extent      : 4480500, 4484666, 5550100, 5554933  (xmin, xmax, ymin, ymax)\n coord. ref. : DHDN / 3-degree Gauss-Kruger zone 4 (EPSG:31468) \n names       :  Name ID_region region_area New_Attr new_Attr2\n type        : <chr>     <int>       <num>    <chr>     <num>\n values      :     a         1   8.853e+06       n1         9\n                   b         2   2.208e+06       n2         6\n```\n:::\n:::\n\n\n\n\n### Delete a attribute\n\n- `$name <- NULL`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Test$New_Attr <- c(\"n1\", \"n2\")\nvect_Test[,\"New_Attr\"] <- c(\"n1\", \"n2\")\n```\n:::\n\n\n## Object Append and aggregate\n\n### Append new Objects\n\n::: {.panel-tabset}\n\n## R\n\n\n- `rbind()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# New Vect\n# Define the coordinate reference system (CRS) with EPSG codes\ncrs_31468 <- \"EPSG:31468\"\n\n# Define coordinates for the first polygon\nx_polygon_3 <- c(4480400, 4481222, 4480500)\ny_polygon_3 <- c(5551000, 5550666, 5552555)\ngeometry_polygon_3 <- cbind(id=3, part=1, x_polygon_3, y_polygon_3)\n\n# Create a vector layer for the polygons, specifying their type, attributes, CRS, and additional attributes\nvect_New <- vect(geometry_polygon_3, type=\"polygons\", atts = data.frame(ID_region = 3, Name = c(\"b\")), crs = crs_31468)\nvect_New$region_area <- expanse(vect_New)\n\n# Append the objects\nvect_Append <- rbind(vect_Test, vect_New)\nvect_Append\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 3, 4  (geometries, attributes)\n extent      : 4480400, 4484666, 5550100, 5554933  (xmin, xmax, ymin, ymax)\n source      : minibeispiel_polygon.geojson\n coord. ref. : DHDN / 3-degree Gauss-Kruger zone 4 (EPSG:31468) \n names       : ID_region  Name region_area New_Attr\n type        :     <int> <chr>       <num>    <chr>\n values      :         1     a   8.853e+06       n1\n                       2     b   2.208e+06       n2\n                       3     b   6.558e+05       NA\n```\n:::\n:::\n\n\n## Python\n\n- `pandas.concat()`\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Define the coordinate reference system (CRS) with EPSG code\ncrs_31468 = \"EPSG:31468\"\n\n# Define coordinates for the new polygon\nx_polygon_3 = [4480400, 4481222, 4480500]\ny_polygon_3 = [5551000, 5550666, 5552555]\n\n# Create a Polygon geometry\ngeometry_polygon_3 = Polygon(zip(x_polygon_3, y_polygon_3))\n\n# Create a GeoDataFrame for the new polygon\nvect_New = gpd.GeoDataFrame({'ID_region': [3], 'Name': ['b'], 'geometry': [geometry_polygon_3]}, crs=crs_31468)\n\n# Calculate the region area\nvect_New['region_area'] = vect_New['geometry'].area\n\n# Append the new GeoDataFrame to the existing one\nvect_Append = gpd.GeoDataFrame(pd.concat([vect_Test, vect_New], ignore_index=True), crs=crs_31468)\n\n# Now, vect_Append contains the combined data\nprint(vect_Append)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   ID_region  ...                                           geometry\n0          1  ...  MULTIPOLYGON (((4484566.000 5554566.000, 44839...\n1          2  ...  MULTIPOLYGON (((4481929.000 5554933.000, 44812...\n2          3  ...  POLYGON ((4480400.000 5551000.000, 4481222.000...\n\n[3 rows x 4 columns]\n```\n:::\n:::\n\n\n:::\n\n\n### Aggregate / Dissolve\n\nIt is common to **aggregate (“dissolve”)** polygons that have the same value for an attribute of interest. \n\n::: {.panel-tabset}\n\n## R\n\n\n- `aggregate()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Aggregate by the \"Name\"\nvect_Aggregated <- terra::aggregate(vect_Append, by = \"Name\")\nvect_Aggregated\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 2, 5  (geometries, attributes)\n extent      : 4480400, 4484666, 5550100, 5554933  (xmin, xmax, ymin, ymax)\n coord. ref. : DHDN / 3-degree Gauss-Kruger zone 4 (EPSG:31468) \n names       :  Name mean_ID_region mean_region_area New_Attr agg_n\n type        : <chr>          <num>            <num>    <chr> <int>\n values      :     a              1        8.853e+06       n1     1\n                   b            2.5        1.432e+06       NA     2\n```\n:::\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot(vect_Append, \"ID_region\")\n```\n\n::: {.cell-output-display}\n![Original](spatial_data_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(vect_Aggregated, \"Name\")\n```\n\n::: {.cell-output-display}\n![Aggregated](spatial_data_files/figure-html/unnamed-chunk-28-2.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Aggregate by the \"Name\"\nvect_Aggregated = vect_Append.dissolve(by=\"Name\", aggfunc=\"first\")\n\nprint(vect_Aggregated)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                                               geometry  ...   region_area\nName                                                     ...              \na     POLYGON ((4484566.000 5554566.000, 4483922.000...  ...  8.853404e+06\nb     POLYGON ((4480400.000 5551000.000, 4480500.000...  ...  2.208109e+06\n\n[2 rows x 3 columns]\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nvect_Test.plot()\nplt.show()\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n\n```{.python .cell-code}\nplt.close()\nvect_Aggregated.plot()\nplt.show()\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-30-2.png){width=672}\n:::\n\n```{.python .cell-code}\nplt.close()\n```\n:::\n\n\n:::\n\n\n\n\n\n\n## Overlap\n\nTo perform operations that involve overlap between two vector datasets, we will create a new vector dataset:\n\n\n::: {.panel-tabset}\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Overlap <- as.polygons(rast_Test)[1,]\nnames(vect_Overlap) <- \"ID_Rast\"\n\nplot(vect_Overlap, \"ID_Rast\")\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-31-5.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Read the raster and get the shapes\nrast_Test = rasterio.open(\"https://raw.githubusercontent.com/HydroSimul/Web/main/data_share/minibeispiel_raster.asc\", 'r+')\nrast_Test.crs = CRS.from_epsg(31468)\ntransform = rast_Test.transform\nshapes = rasterio.features.shapes(rast_Test.read(1), transform=transform)\n\n# Convert the shapes to a GeoDataFrame\ngeometries = [shape(s) for s, v in shapes if v == 1]\nvect_Overlap = gpd.GeoDataFrame({'geometry': geometries})\n\n# Add an \"ID_Rast\" column to the GeoDataFrame\nvect_Overlap['ID_Rast'] = range(1, len(geometries) + 1)\nvect_Overlap.crs =\"EPSG:31468\"\n\n# Plot the polygons with \"ID_Rast\" as the attribute\nvect_Overlap.plot(column='ID_Rast')\nplt.show()\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n\n```{.python .cell-code}\nplt.close()\n```\n:::\n\n\n:::\n\n\n### Erase\n\n\n::: {.panel-tabset}\n\n## R\n\n- `erase()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Erase <- erase(vect_Test, vect_Overlap)\nplot(vect_Erase, \"ID_region\")\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-33-3.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nvect_Erase = gpd.overlay(vect_Test, vect_Overlap, how='difference')\nvect_Erase.plot(column='ID_region', cmap='jet')\nplt.show()\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n\n```{.python .cell-code}\nplt.close()\n```\n:::\n\n\n:::\n\n\n### Intersect\n\n::: {.panel-tabset}\n\n## R\n\n- `intersect()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Intersect <- terra::intersect(vect_Test, vect_Overlap)\nplot(vect_Intersect, \"ID_region\")\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-35-3.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nvect_Intersect = gpd.overlay(vect_Test, vect_Overlap, how='intersection')\nvect_Intersect.plot(column='ID_region', cmap='jet')\nplt.show()\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n\n```{.python .cell-code}\nplt.close()\n```\n:::\n\n\n:::\n\n\n### Union\n\nAppends the geometries and attributes of the input. \n\n::: {.panel-tabset}\n\n## R\n\n- `union()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Union <- terra::union(vect_Test, vect_Overlap)\nplot(vect_Union, \"ID_region\")\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-37-3.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nvect_Union = gpd.overlay(vect_Test, vect_Overlap, how='union')\nvect_Union.plot(column='ID_region', cmap='jet')\nplt.show()\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n\n```{.python .cell-code}\nplt.close()\n```\n:::\n\n\n:::\n\n\n### Cover\n\n`cover()` is a combination of `intersect()` and `union()`. intersect returns new (intersected) geometries with the attributes of both input datasets. union appends the geometries and attributes of the input. cover returns the intersection and appends the other geometries and attributes of both datasets.\n\n\n\n\n::: {.panel-tabset}\n\n## R\n\n- `cover()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Cover <- terra::cover(vect_Test, vect_Overlap)\nplot(vect_Cover, \"ID_region\")\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-39-3.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nvect_Cover = gpd.overlay(vect_Test, vect_Overlap, how='identity')\nvect_Cover.plot(column='ID_region', cmap='jet')\nplt.show()\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n\n```{.python .cell-code}\nplt.close()\n```\n:::\n\n\n:::\n\n\n\n### Difference\n\n\n::: {.panel-tabset}\n\n## R\n\n- `symdif()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvect_Difference <- terra::symdif(vect_Test, vect_Overlap)\nplot(vect_Difference, \"ID_region\")\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-41-3.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nvect_Difference = gpd.overlay(vect_Test, vect_Overlap, how='symmetric_difference')\nvect_Difference.plot(column='ID_region', cmap='jet')\nplt.show()\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-42-1.png){width=672}\n:::\n\n```{.python .cell-code}\nplt.close()\n```\n:::\n\n\n:::\n\n\n# Raster data manipulation\n\nCompared to vector data, raster data stores **continuous numeric** values more, leading to significant differences in manipulation and analysis approaches.\n\n\n::: {.panel-tabset}\n\nIn Python, raster data is treated as an array. To work with it, we can create a new variable, 'rast_Test_data':\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nrast_Test = rasterio.open(\"https://raw.githubusercontent.com/HydroSimul/Web/main/data_share/minibeispiel_raster.asc\", 'r+')\nrast_Test.crs = CRS.from_epsg(31468)\nrast_Test_data = rast_Test.read(1)\nrast_Test_data[rast_Test_data == -9999] = np.nan\n```\n:::\n\n\n:::\n\n## Raster algebra\n\nMany generic functions that allow for simple and elegant raster **algebra** have been implemented for Raster objects, including the normal algebraic operators such as `+`, `-`, `*`, `/`, logical operators such as `>`, `>=`, `<`, `==`, `!`, and functions like `abs`, `round`, `ceiling`, `floor`, `trunc`, `sqrt`, `log`, `log10`, `exp`, `cos`, `sin`, `atan`, `tan`, `max`, `min`, `range`, `prod`, `sum`, `any`, `all`. In these functions, you can mix raster objects with numbers, as long as the first argument is a raster object. ([Spatial Data Science](https://rspatial.org/spatial/index.html))\n\n\n\n::: {.panel-tabset}\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrast_Add <- rast_Test + 10\nplot(rast_Add)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-44-3.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nrast_Add = rast_Test_data + 10\nrast_plot(rast_Add)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-45-1.png){width=672}\n:::\n:::\n\n\n:::\n\n\n## Replace with Condition\n\n::: {.panel-tabset}\n\n## R\n\n\n- `rast[condition] <- `\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Copy to a new raster\nrast_Replace <- rast_Test\n\n# Replace\nrast_Replace[rast_Replace > 1] <- 10\nplot(rast_Replace)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-46-3.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nrast_Replace = rast_Test_data\n\n# Replace values greater than 1 with 10\nrast_Replace[rast_Replace > 1] = 10\nrast_plot(rast_Replace)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-47-1.png){width=672}\n:::\n:::\n\n\n:::\n\n\n## Summary of multi-layers\n\n\n::: {.panel-tabset}\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrast_Mean <- mean(rast_Test, rast_Replace)\nplot(rast_Mean)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-48-3.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nrast_Mean = (rast_Test_data + rast_Replace) / 2\nrast_plot(rast_Mean)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-49-1.png){width=672}\n:::\n:::\n\n\n:::\n\n\n## Aggregate and disaggregate\n\n\n::: {.panel-tabset}\n\n## R\n\n\n- `aggregate()`\n- `disagg()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Aggregate by factor 2\nrast_Aggregate <- aggregate(rast_Test, 2)\nplot(rast_Aggregate)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-50-3.png){width=672}\n:::\n\n```{.r .cell-code}\n# Disaggregate by factor 2\nrast_Disagg <- disagg(rast_Test, 2)\nrast_Disagg\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 10, 10, 1  (nrow, ncol, nlyr)\nresolution  : 500, 500  (x, y)\nextent      : 4480000, 4485000, 5550000, 5555000  (xmin, xmax, ymin, ymax)\ncoord. ref. : DHDN / 3-degree Gauss-Kruger zone 4 (EPSG:31468) \nsource(s)   : memory\nname        : minibeispiel_raster \nmin value   :                   1 \nmax value   :                   3 \n```\n:::\n\n```{.r .cell-code}\nplot(rast_Disagg)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-50-4.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Aggregate by factor 2\nrast_Aggregate = rast_Test_data\nrast_Aggregate = rast_Aggregate[::2, ::2]\nrast_plot(rast_Aggregate)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-51-1.png){width=672}\n:::\n\n```{.python .cell-code}\n# Disaggregate by factor 2\nrast_Disagg = rast_Test_data\nrast_Disagg = np.repeat(np.repeat(rast_Disagg, 2, axis=0), 2, axis=1)\nrast_plot(rast_Disagg)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-51-2.png){width=672}\n:::\n:::\n\n\n:::\n\n\n## Crop\n\nThe crop function lets you take a geographic **subset** of a larger raster object with an **extent**. But you can also use other spatial object, in them an extent can be extracted.\n\n\n- `crop()`\n  - with extention\n  - with rster\n  - with vector\n  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrast_Crop <- crop(rast_Test, vect_Test[1,])\nplot(rast_Crop)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-52-5.png){width=672}\n:::\n:::\n\n\n\n\n## Trim\n\n- `trim()`\n\nTrim (shrink) a `SpatRaster` by **removing outer rows and columns** that are NA or another value.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrast_Trim0 <- rast_Test\nrast_Trim0[21:25] <- NA\nrast_Trim <- trim(rast_Trim0)\n```\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot(rast_Trim0)\n```\n\n::: {.cell-output-display}\n![with NA](spatial_data_files/figure-html/unnamed-chunk-54-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(rast_Trim)\n```\n\n::: {.cell-output-display}\n![Trimed](spatial_data_files/figure-html/unnamed-chunk-54-2.png){width=672}\n:::\n:::\n\n\n\n## Mask\n\n::: {.panel-tabset}\n\n## R\n\n\n- `mask()`\n- `crop(mask = TRUE)` = `mask()` + `trim()`\n\nWhen you use mask manipulation in spatial data analysis, it involves setting the cells that are **not covered** by a mask to NA (Not Available) values. If you apply the `crop(mask = TRUE)` operation, it means that not only will the cells outside of the mask be set to NA, but the resulting raster will also be cropped to match the extent of the mask.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrast_Mask <- mask(rast_Disagg, vect_Test[1,])\nrast_CropMask <- crop(rast_Disagg, vect_Test[1,], mask = TRUE)\n```\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nplot(rast_Mask)\n```\n\n::: {.cell-output-display}\n![Mask](spatial_data_files/figure-html/unnamed-chunk-56-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(rast_CropMask)\n```\n\n::: {.cell-output-display}\n![Mask + Crop (Trim)](spatial_data_files/figure-html/unnamed-chunk-56-2.png){width=672}\n:::\n:::\n\n\n## Python\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nvect_Mask = vect_Test.iloc[0:1].geometry.values[0]\n\n# Create a mask for the vect_Mask on the raster\nrast_Mask = rasterio.features.geometry_mask([vect_Mask], out_shape=rast_Test.shape, transform=rast_Test.transform, invert=True)\n# Apply the mask to the raster\nrast_Crop = rast_Test_data.copy()\nrast_Crop[~rast_Mask] = rast_Test.nodata  # Set values outside the geometry to nodata\n\nrast_plot(rast_Crop)\n```\n\n::: {.cell-output-display}\n![](spatial_data_files/figure-html/unnamed-chunk-57-1.png){width=672}\n:::\n:::\n\n\n:::\n\n\n",
    "supporting": [
      "spatial_data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}