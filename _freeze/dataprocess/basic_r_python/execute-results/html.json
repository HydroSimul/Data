{
  "hash": "691d06c19c1c17f5f87bd9879789799d",
  "result": {
    "markdown": "---\ntitle: \"R & Python Basic\"\nnumber-sections: true\n---\n\n\nMore Details of R in [R for Data Science (2e)](https://r4ds.hadley.nz/workflow-basics) and [Advanced R](https://adv-r.hadley.nz/index.html)\n\nMore Details of Python in [W3 School Python](https://www.w3schools.com/python/default.asp)\n\nThis article serves as a **brief introduction** to the fundamental coding aspects of both R and Python. \nIt provides a first impression of these scripting languages. For a more comprehensive understanding and in-depth techniques related to both languages, you are encouraged to explore the website mentioned above. The content here is primarily a condensed compilation of information from the provided links, aimed at facilitating a comparison between R and Python.\n\n\n**Data** and **Functions** are the two essential components of every programming language, especially in the context of data science and data processing. They can be likened to nouns and verbs in natural languages. **Data** describes information, while **Functions** define actions for manipulating that data.\n\nThis article is divided into two main sections: **Data** (@sec-data) and **Coding** (@sec-coding).\n\n\nIn the Data section, we will explore:\n\n- Basic **data types**, such as numbers, characters, and booleans.\n- **Data structures** for organizing groups of values, such as vectors and lists.\n\n\nIn the Coding section, we will delve into three key aspects:\n\n1. Fundamental **mathematics**.\n2. Control flow, including decision-making (**choices**) and **looping**.\n3. Creating and invoking **functions**.\n\nThe above five elements can be considered as the most fundamental elements of every scripting language. Additionally, we will explore **object creation and naming** in a section called 'New Objects' (@sec-naming). Objects can encompass functions and variables, further enriching our understanding of scripting.\n\nThis article will provide a solid introduction to the core concepts in programming, laying the groundwork for further exploration in both R and Python.\n\n\n# Data {#sec-data}\n\n## Datatype\n\n## Data Structure\n\n# Coding {#sec-coding}\n\n## math calculations \n\n- '+' '-' '*' '/'\n- Exponent, Logarithm\n- Trigonometric functions\n- Linear algebra, Matrix multiplication\n\n::: {.panel-tabset}\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 / 200 * 30\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.15\n```\n:::\n\n```{.r .cell-code}\n(59 + 73 - 2) / 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 43.33333\n```\n:::\n\n```{.r .cell-code}\n3^2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n\n```{.r .cell-code}\nsin(pi / 2) # pi as Const number in R\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nprint(1 / 200 * 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.15\n```\n:::\n\n```{.python .cell-code}\nprint((59 + 73 - 2) / 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n43.333333333333336\n```\n:::\n\n```{.python .cell-code}\nprint(3**2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n9\n```\n:::\n\n```{.python .cell-code}\nimport math\nprint(math.sin(math.pi/2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.0\n```\n:::\n:::\n\n\n:::\n\n## Control flow\n\nThere are two primary tools of control flow: choices and loops. \n\n- **Choices**, like `if` statements calls, allow you to run different code **depending on the input**. \n- **Loops**, like for and while, allow you to **repeatedly** run code, typically with changing options.\n\n### choices \n\n#### Basic If-Else\n\n::: {.panel-tabset}\n\n## R\n\nThe basic form of an if statement in R is as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (condition) true_action\nif (condition) true_action else false_action\n```\n:::\n\n\nIf `condition` is `TRUE`, `true_action` is evaluated; if `condition` is `FALSE`, the optional `false_action` is evaluated. \n\nTypically the actions are compound statements contained within `{`:\n\n`if` returns a value so that you can assign the results:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 6\nb <- 8\n\nif (b > a) {\n  cat(\"b is greater than a\\n\")\n} else if (a == b) {\n  cat(\"a and b are equal\\n\")\n} else {\n  cat(\"a is greater than b\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nb is greater than a\n```\n:::\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# if statements\nif condition: \n  true_action\n  \n# if-else\nif condition: \n  true_action \nelse: \n  false_action\n\n\n# if-ifel-else\nif condition1: \n  true_action1 \nelif condition2: \n  true_action2 \nelse: \n  false_action\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\na = 6\nb = 8\nif b > a:\n  print(\"b is greater than a\")\nelif a == b:\n  print(\"a and b are equal\")\nelse:\n  print(\"a is greater than b\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nb is greater than a\n```\n:::\n:::\n\n\n:::\n\n\n#### switch\n\n::: {.panel-tabset}\n\n## R\n\nClosely related to `if` is the `switch()`-statement. It's a compact, special purpose equivalent that lets you replace code like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_option <- function(x) {\n  if (x == \"a\") {\n    \"option 1\"\n  } else if (x == \"b\") {\n    \"option 2\" \n  } else if (x == \"c\") {\n    \"option 3\"\n  } else {\n    stop(\"Invalid `x` value\")\n  }\n}\n```\n:::\n\n\nwith the more succinct:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_option <- function(x) {\n  switch(x,\n    a = \"option 1\",\n    b = \"option 2\",\n    c = \"option 3\",\n    stop(\"Invalid `x` value\")\n  )\n}\nx_option(\"b\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"option 2\"\n```\n:::\n:::\n\n\nThe last component of a `switch()` should always throw an error, otherwise unmatched inputs will invisibly return `NULL`:\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmatch subject:\n    case <pattern_1>:\n        <action_1>\n    case <pattern_2>:\n        <action_2>\n    case <pattern_3>:\n        <action_3>\n    case _:\n        <action_wildcard>\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndef x_option(x):\n    options = {\n        \"a\": \"option 1\",\n        \"b\": \"option 2\",\n        \"c\": \"option 3\"\n    }\n    return options.get(x, \"Invalid `x` value\")\n\nprint(x_option(\"b\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\noption 2\n```\n:::\n:::\n\n\n:::\n\n\n#### Vectorised if\n\n::: {.panel-tabset}\n\n## R\n\nGiven that `if` only works with a single `TRUE` or `FALSE`, you might wonder what to do if you have a vector of logical values. Handling vectors of values is the job of `ifelse()`: a vectorised function with `test`, `yes`, and `no` vectors (that will be recycled to the same length):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\nifelse(x %% 5 == 0, \"XXX\", as.character(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"1\"   \"2\"   \"3\"   \"4\"   \"XXX\" \"6\"   \"7\"   \"8\"   \"9\"   \"XXX\"\n```\n:::\n\n```{.r .cell-code}\nifelse(x %% 2 == 0, \"even\", \"odd\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\" \"odd\"  \"even\"\n```\n:::\n:::\n\n\nNote that missing values will be propagated into the output.\n\nI recommend using `ifelse()` only when the `yes` and `no` vectors are the same type as it is otherwise hard to predict the output type. See <https://vctrs.r-lib.org/articles/stability.html#ifelse> for additional discussion.\n\n\n## Python\n\n:::\n\n\n### Loops\n\n#### `for`-Loops\n\nA for loop is used for iterating over a sequence (that is either a list, a tuple, a dictionary, a set, or a string).\nFor each item in `vector`, `perform_action` is called once; updating the value of `item` each time.\n\n::: {.panel-tabset}\n\n## R\n\nIn R, `for` loops are used to iterate over items in a vector. They have the following basic form:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (item in vector) perform_action\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:3) {\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n```\n:::\n:::\n\n\n\n## Python\n\n::: {.cell}\n\n```{.python .cell-code}\nfor item in vector \n  perform_action\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nfor i in range(1, 3):\n  print(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n```\n:::\n:::\n\n\n\n:::\n\n#### `while`-Loops\n\nWith the while loop we can execute a set of statements as long as a condition is `TRUE`:\n\n::: {.panel-tabset}\n\n## R\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 1\nwhile (i < 6) {\n  print(i)\n  i <- i + 1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n```\n:::\n:::\n\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ni = 1\nwhile i < 6:\n  print(i)\n  i += 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\n4\n5\n```\n:::\n:::\n\n\n\n:::\n\n\n#### terminate \n\n::: {.panel-tabset}\n\n## R\n\nThere are two ways to terminate a `for` loop early:\n\n* `next` exits the current iteration.\n* `break` exits the entire `for` loop.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:10) {\n  if (i < 3) \n    next\n\n  print(i)\n  \n  if (i >= 5)\n    break\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n[1] 4\n[1] 5\n```\n:::\n:::\n\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfor i in range(1, 10):\n    if i < 3:\n        continue\n    \n    print(i)\n    \n    if i >= 5:\n        break\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n4\n5\n```\n:::\n:::\n\n\n\n:::\n\n## Function\n\nMore details of in [Advanced R Chapter 6](https://adv-r.hadley.nz/functions.html)\n\nA function is a block of code which only runs when it is called.\nIt can be broken down into three components:\n\n* The `formals()`, the list of **arguments** that control how you call the function.\n  \n* The `body()`, the **code** inside the function.\n\n* The `environment()`, the data structure that determines how the function **finds** \nthe values associated with the **names**.\n\nWhile the formals and body are specified explicitly when you create a function, the environment is specified implicitly, based on _where_ you defined the function. This location could be within another package or within the workspace (global environment).\n\n::: {.panel-tabset}\n\n## R\n\nThe function environment always exists, but it is only printed when the function isn't defined in the global environment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf02 <- function(x, y) {\n  # A comment\n  x + y\n}\n\nformals(f02)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$x\n\n\n$y\n```\n:::\n\n```{.r .cell-code}\nbody(f02)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{\n    x + y\n}\n```\n:::\n\n```{.r .cell-code}\nenvironment(f02)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<environment: R_GlobalEnv>\n```\n:::\n:::\n\n\n## Python\n\n\n:::\n\n\n### Calling\n\n::: {.panel-tabset}\n\n## R\n\nCalling Syntax:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction_name(argument1 = value1, argument2 = value2, ...)\n```\n:::\n\n\n\nTry using `seq()`, which makes regular **seq**uences of numbers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(from = 1, to = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n:::\n\n\nWe often omit the names of the first several arguments in function calls, so we can rewrite this as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(1, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n:::\n\n\nWe can also check the arguments and other information with:\n\n```{.r}\n?seq\n```\n\nThe \"help\" windows shows as:\n\n![](../images/r-help.png)\n\n## Python\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsequence = list(range(1, 11))\nprint(sequence)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n```\n:::\n:::\n\n\n\n:::\n\n### Creating \n\n::: {.panel-tabset}\n\n## R\n\nUse the function() keyword:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_add1 <- function(x) {\n  x + 1\n}\n```\n:::\n\n\ncalling the function `my_add1`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_add1(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\n::: {.callout-tip}\nIn R, the return statement is not essential for a function to yield a value as its result. By default, R will return the result of the last command within the function as its output.\n:::\n\n\n## Python\n\nIn Python a function is defined using the `def` keyword:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef my_add(x):\n  return x + 1\n```\n:::\n\n\ncalling the function `my_add1`:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nprint(my_add(2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n```\n:::\n:::\n\n\n\n::: {.callout-warning}\nThe `return` statement is essential for a function to yield a value as its result.\n\n:::\n:::\n\n\n# New objects {#sec-naming}\n\n\n::: {.panel-tabset}\n\n## R\n\nCreate new objects with the assignment operator `<-`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# \"<-\" special in R \n\na <- 1 / 200 * 30\nb <- a + 1\n```\n:::\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\na = 1 / 200 * 30\nb = a + 1\n\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.15\n```\n:::\n\n```{.python .cell-code}\nprint(b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.15\n```\n:::\n:::\n\n\n\n:::\n\n## Naming rules\n\n\n::: {.panel-tabset}\n\n## R\n\n- must start with a letter\n- can only contain letters, numbers, underscores `_`, and dot `.`\n- case-sensitive (age, Age and AGE are three different variables)\n- cannot be any of the Reserved Words\n  - `TRUE` `FALSE`\n  - `NULL` `Inf` `NaN` `NA` `NA_real` `NA_complex_` `NA_character_`\n  - `if` `else`\n  - `for` `while` `repeat` \n  - `next` `break`\n  - `function` \n  - `in`\n\n\n:::: {.columns}\n\n::: {.column width=\"48%\"}\n::: {.callout-tip}\n## Legal \n\ni_use_snake_case\n\notherPeopleUseCamelCase\n\nsome.people.use.periods\n\naFew.People_RENOUNCEconvention6\n:::\n\n:::\n\n::: {.column width=\"4%\"}\n:::\n\n::: {.column width=\"48%\"}\n::: {.callout-warning}\n## Illegal \n\n_start_with_underscores\n\n1_start_with_number\n\nif\n\ncontain sapce\n\ncontain-other+charater\n\n:::\n\n:::\n\n::::\n\nmore Reserved Words in:\n\n```{.r}\nhelp(\"reserved\")\n```\n\n\n## Python\n\n- must start with a letter or the **underscore character `_`**\n- can only contain letters, numbers, and underscores `_` \n- case-sensitive (age, Age and AGE are three different variables)\n- cannot be any of the Python keywords (35 keywors in Python 3.8)\n  - `True` `False`\n  - `None` \n  - `if` `else` `elif`\n  - `for` `while` `repeat` \n  - `try` `break` `continue` `finally`\n  - `def`\n  - `in` `and` `or` `not`\n  - `return`\n\n:::: {.columns}\n\n::: {.column width=\"48%\"}\n::: {.callout-tip}\n## Legal \n\ni_use_snake_case\n\n_start_with_underscores\n\notherPeopleUseCamelCase\n\n\naFew_People_RENOUNCEconvention6\n:::\n\n:::\n\n::: {.column width=\"4%\"}\n:::\n\n::: {.column width=\"48%\"}\n::: {.callout-warning}\n## Illegal \n\nwant.contain.dot\n\n1_start_with_number\n\nif\n\ncontain sapce\n\ncontain-other+charater\n\n:::\n\n:::\n\n::::\n\nMore Keywords in:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nhelp(\"keywords\")\n```\n:::\n\n\n:::\n\n## Naming Conventions \n\n- **Camel Case**\n  - Each word, except the first, starts with a capital letter:\n  - `myVariableName` \n- **Pascal Case**\n  - Each word starts with a capital letter:\n  - `MyVariableName` \n- **Snake Case**\n  - Each word is separated by an underscore character:\n  - `my_variable_name` \n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}